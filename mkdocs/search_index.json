{
    "docs": [
        {
            "location": "/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nInfomatics Notes",
            "title": "Home"
        },
        {
            "location": "/#infomatics-notes",
            "text": "",
            "title": "Infomatics Notes"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nPropositonal Logic\n\n\nPropositions\n\n\n\n\nProposition\n\n\nA declarative sentence (declares a fact) that is either true or false.\n\n\n\n\n\n\n\n\n\n\nPropositon\n\n\nNot propositions\n\n\n\n\n\n\n\n\n\n\nIt is raining.\n\n\nWhat is the data?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLogical operators\n\n\nFrom these propositions we can from new compound propositions with logical operators:\n\n\n\n\n\n\n\n\nOperation\n\n\nExample\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nNegation\n\n\n\n\nit is not the case that \n\n\n\n\n\n\nConjunction\n\n\n\n\nboth \n and \n must be true for \n to be true\n\n\n\n\n\n\nDisjunction\n\n\n\n\nFalse when both \n and \n are false, true otherwise\n\n\n\n\n\n\nExclusive Or\n\n\n\n\nEither \n or \n must be true (\nnot both\n) for \n to be true\n\n\n\n\n\n\nImplication\n\n\n\n\nFalse when \n is true and \n is false, true otherwise. \n is the hypothesis/antecedent and \n is the conclusion/conseqence\n\n\n\n\n\n\nBiconditional\n\n\n\n\n if and only if \n, true when both \n and \n have the same truth values\n\n\n\n\n\n\n\n\nTruth tables\n\n\nWith these logical operators we can build complex logical statements such as: \n. To construct truth tables for these expressions we start with the individual variables \n and \n, and solve sub expressions until we reach the full expression.\n\n\n\n\nOperator precedence\n\n\nThe order of which operators apply are as follows:\n\n\n\n\n\n\n\n\nOperator\n\n\nPrecedence\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\nLogical Equivalences\n\n\n\n\nTautology\n\n\nA compound proposition that is \ntrue\n, no matter what values the propositional variables hold.\n\n\nContradiction\n\n\nA compound proposition that is \nfalse\n, no matter what values the propositional variables hold.\n\n\nContingency\n\n\nCompound propositions that are neither a tautology or a contradiction.\n\n\n\n\n\n\n is a tautology\n\n\n is a contradiction\n\n\n is a contingency\n\n\n\n\nTwo compound propositions are \nlogically equivilent\n if they have the same truth values in all cases. This occors when \n is a tautology, where \n and \n are compound propositions. \n is a statement, denoting that \n and \n are logically equivilent.\n\n\nImportant Equivalences\n\n\n\n\n\n\n\n\nEquivalence\n\n\nName\n\n\n\n\n\n\n\n\n\n\n\n\nIdentity laws\n\n\n\n\n\n\n\n\nDomination laws\n\n\n\n\n\n\n\n\nIdempotent laws\n\n\n\n\n\n\n\n\nDouble negation law\n\n\n\n\n\n\n\n\nCommutative laws\n\n\n\n\n\n\n\n\nAssociative laws\n\n\n\n\n\n\n\n\nDistributive laws\n\n\n\n\n\n\n\n\nDe Morgan's laws\n\n\n\n\n\n\n\n\nAbsorption laws\n\n\n\n\n\n\n\n\nNegation laws\n\n\n\n\n\n\n\n\nLogical equivalences involving conditional statements\n\n\n\n\n\n\n\n\nLogical equivalences involving biconditionals\n\n\n\n\n\n\n\n\nNotation\n\n\nSimular to \n, their exsists a notation for \n and \n.\n\n\n\n\n\n\nConstructing new logical equivalences\n\n\nUsing equivalences we already know, we can prove expressions are tautologys or that two expressions are logically equivelent. While a truth table could also be used, it is much shorted to apply laws.\n\n\n\n\nShow that \n is a tautology.\n\n\n\n\n\nSatisfaction\n\n\n\n\nSatisfiable\n\n\nA compound proposition were there \nis a\n assignment of truth values that make it true.\n\n\nUnsatisfiable\n\n\nA compound proposition were there \nis no\n assignment of truth values that make it true.\n\n\n\n\nThe values which make a compound proposition true is called the \nsolution to the satisfiability problem\n.\n\n\nPredicates and Quantifiers\n\n\nPredicates\n\n\nStatements that involve variables such as \n and \n are undecided when their variables are not given a value. We need a more powerfull logic, \npredicate logic\n, to model these statements.\n\n\nWe turn the statement \n into the predicate \n where \n is \n. When we give \n a value, the statement becomes a proposition, e.g. \n becomes \n which is \n.\n\n\nA predicate can have any number of variables, \n. A predicate with \n variables is called an \n-ary predicate.\n\n\nQuantifiers\n\n\nAssigning variables is not the only way to form a proposition from a predicate. \nQuantification\n expresses the extend to which a predicate is true over a range.\n\n\n\n\n\n\n\n\nName\n\n\nExample\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUniversal quantifier\n\n\n\n\nis true if \n is true for all x (domain)\n\n\n\n\n\n\nExistential quantifier\n\n\n\n\nis true if \n is true for at least one value in the domain\n\n\n\n\n\n\n\n\n\n\nIs \n where the domain is all real numbers true.\n\n\nNo, if \n, \n) is false, thus not all elements in the domain make \n true.\n\n\n\n\nRestricting the domain\n\n\nConsider \n where the domain of \n is \n. We could express that as:\n\n\n\n\nTheir is a shorter notation for restricting the domain\n\n\n\n\nPrecedence of Quantifiers\n\n\n and \n have a higher precedence that all other logical operators.\n\n\nBinding Variables\n\n\nWhen a quantifier is used on variable, or the variable is assigned a value, the variable is said to be \nbound\n. Predicates must have all the variables bound to be turned into a proposition. Variables that are not bound are \nfree\n.\n\n\nThe \nscope\n of a quantifier is the part of the logical expression to which it is applied, hence variables outside of the scope of all quantifiers are free (if their value has not been assigned).\n\n\nLogical Equivalence\n\n\nTwo expressions involving predicates and quantifiers are equal if their truth values are the same throughout the domain.\n\n\n\n\nShow that \n and \n are logically equivalent.\n\n\n\n\nLet \n be some element in the domain, thus \n must be \n.\n\n\nIf \n is \n, \n and \n must both be \n.\n\n\nSince \n and \n are \n for all element in the domain, \n must also be $\\top$.\n\n\n\n\nSo\n\n\n\n\n\nNegation\n\n\n\n\n\n\n\n\nStatement\n\n\nEquivalent\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTheir is an \n for which \n is \n\n\n\n\n\n\n\n\n\n\nFor every \n, \n is \n\n\n\n\n\n\n\n\n\n\nProve \n\n\n\n\n is \n, if and only if \n is \n\n\nIf \n is \n, then their is atleast one element in the domain for which \n is true.\n\n\nIt follows then the \n\n\n\n\n\n\nNested Quantifiers\n\n\nMore complex statements often involve more than one quantifier. For example the logical statement that \nif \n is positive and \n is negative, \n is negative\n can be expressed as:\n\n\n\n\nProof\n\n\nRules of Inference\n\n\nProofs are mathmatical arguments that determine the truth of a statement. \nBy an argument\n, means a sequence of statements that end in a conclusion. \nBy valid\n, means the conclusion must follow from the arguments. \nBy premise\n, means the argument is valid if and only if it is impossible for all premises to be true and the conclusion false.\n\n\nAn \nargument\n is propositional logic is a sequence of propositons, where the final proposition is the conclusion and all others are the premises. An \nargument form\n in propositional logic is a sequence of compound propositions that is \nvalid\n no matter what propositions are substitude for a premise, so long as the premises are true.\n\n\nThe \nmodus ponens\n (law of detachment) is one rule we can use to proof statements. \n\n\n\n\n\nLet \n be \"it snows\" and \n be \"will go skiing\", if \"we will go skiing if it snows\" is \"we will go skiing\" true?\n\n\n\n\n\n\n\n\n\n\n\n\nRule of Inference\n\n\nTautology\n\n\nName\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModus ponens\n\n\n\n\n\n\n\n\n\n\nModus tollens\n\n\n\n\n\n\n\n\n\n\nHypothetical syllogism\n\n\n\n\n\n\n\n\n\n\nDisjunctive syllogism\n\n\n\n\n\n\n\n\n\n\nAddition\n\n\n\n\n\n\n\n\n\n\nSimplification\n\n\n\n\n\n\n\n\n\n\nConjunction\n\n\n\n\n\n\n\n\n\n\nResolution\n\n\n\n\n\n\n\n\nUsing Rules of Inference to Build Arguments\n\n\n\n\nGiven the premesis: \n, \n, \n, \n find an argument that shows the premisies lead to the conclusion \n.\n\n\n\n\n\n\nFallacies\n\n\n is a tautology, fallacies often look like tautologys but are just contingencies:\n\n\n\n\nFallacy of affirming the conclusion\n\n\noccors when \n is treated as a tautology, but it is false when \n is false and \n is true.\n\n\nFallacy of denying the hypothesis\n\n\noccors when \n is treated as a tautology, but it is false when \n is false and \n is true.\n\n\n\n\nRules of Inference for Quantified Statements\n\n\n\n\n\n\n\n\nRule of Inference\n\n\nName\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n\n\nUniversal instantiation\n\n\n is true, where \n is an element of the domain, since all elements are true.\n\n\n\n\n\n\n\n\nUniversal generalization\n\n\n is true, if \n (where \n is an arbitary element in the domain) is true. Since we do not make any assumptions about \n, other than its an element of the domain, all values of the domain must be true.\n\n\n\n\n\n\n\n\nExistential instantiation\n\n\nTheir is an element \n in the domain that makes \n true. Note \n is not arbitary since some elements in the domain do not make \n true.\n\n\n\n\n\n\n\n\nExistential generalization\n\n\nIf we know one element \n in the domain that makes \n true, then it follows that \n\n\n\n\n\n\n\n\n\n\nShow that the premesis \"A student in the class has not read the book\" and \"Everyone in the class passed the exam\" implys the conclusion that \"Someone who passed the exam had not read the book\"\n\n\n\n\nLet \n be \"\n is in the class\"\n\n\nLet \n be \"\n passed the exam\"\n\n\nLet \n be \"\n has read the book\"\n\n\n\n\n\n\n\n\nSet\n\n\nAn unordered collection of elements\n\n\nSet Operations\n\n\n\n\n\n\n\n\nName\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nEquality\n\n\n\n\n\n\n\n\nMembership\n\n\n\n\n\n\n\n\nNon-Membership\n\n\n\n\n\n\n\n\nEmpty Set\n\n\n\n\n\n\n\n\nUnion\n\n\n\n\n\n\n\n\nIntersection\n\n\n\n\n\n\n\n\nDiffrence\n\n\n\n\n\n\n\n\nComplement\n\n\n\n\n\n\n\n\nSubset\n\n\n\n\n\n\n\n\nSuperset\n\n\n\n\n\n\n\n\nPower Set\n\n\n (set of all subsets)\n\n\n\n\n\n\nCardinality\n\n\n\n\n\n\n\n\nCartesian Product\n\n\n\n\n\n\n\n\n\n\nCommon Sets\n\n\n\n\n\n\n\n\nName\n\n\nSymbol\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBooleans\n\n\n\n\n\n\n\n\n\n\nNatural numbers\n\n\n\n\n\n\n\n\n\n\nInteger\n\n\n\n\n\n\n\n\n\n\nPositive Integers\n\n\n\n\n\n\n\n\n\n\nReal Numbers\n\n\n\n\n\n\n\n\n\n\nRational\n\n\n\n\n\n\n\n\n\n\nComplex Numbers\n\n\n\n\n\n\n\n\n\n\n\n\nSet Identitys\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nSyntax\n\n\nA function \n from set \n to set \n assigns an element from \n to \n, this is written as \n.\n\n\nExamples:\n\n\n\n\nCeil - \n\n\nFloor - \n\n\nIdentity - \n\n\nFactorial - \n\n\n\n\nInjective\n\n\n iff \n\n\nFor every element in A their is an element in B which maps to it.\n\n\nExamples:\n\n\n\n\nIdentity function\n\n\n\n\n\n\nSurjective\n\n\n is surjective iff \n\n\nFor every element in B, their is an element in A which is mapped onto it.\n\n\nExamples:\n\n\n\n\nIdentity function\n\n\n for \n\n\n\n\nOne-to-one correspondence or bijection\n\n\n is a bijection iff it is both injective and bijective\n\n\nEvery element in the domain is mapped to a value in the range and visa-versa.\n\n\nExamples\n\n\n\n\nIdentity function\n\n\n\n\n\n\nComposition\n\n\nLet \n and \n. The composition function \n is \n\n\n\n\nThe composition of two functions is a function\n\n\nThe composition of two injective functions is a injective function\n\n\nThe composition of two surjective functions is a surjective function\n\n\nThe composition of two bijections is a bijection\n\n\n\n\nInverse\n\n\nIf \n is a bijection, then the inverse of \n, written \n is \n iff \n\n\n\n\nInverse of the identity function, is the identity function\n\n\nInverse of \n is \n \n\n\n and \n is the identity function\n\n\n\n\nRelations\n\n\nA binary relation \n on sets \n and \n is a subset \n\n\n\n\nOften written as \n for \n\n\nA function \n is a restricted relation where \n\n\nFor all a in \n their exsists a \n in \n\n\nwhere (a, b) in relation \n\n\nand \n is unique  \n\n\n\n\n\n\nGiven sets \n a subset \n is an \n-ary relation.\n\n\n\n\n where \n is students and \n is courses, \n\n\nOperations\n\n\nRelations are sets, so we can use the same operations, i.e. \n or \n\n\nRealtion composition\n\n\nLet \n and \n. The composition relation \n is \n\n\nThe expression specifys the relations where \n and \n have a common \n, thus \n\n\nClosure \n is a relation on \n:\n\n\n\n\n is the identity relation \n\n\n\n\n\n\n\n\nGraph reachability\n\n\nProperties\n\n\n\n\nReflexive iff \n.\n\n\n, \n and \n are reflexive, but \n is not.\n\n\nSymetic iff \n.\n\n\n is symmetic, but \n, \n and \n are not.\n\n\nantisymetic iff \n.\n\n\n, \n, \n are antisymmetic but \n is not.\n\n\ntransitive iff \n.\n\n\n, \n, \n and \n are transitive.\n\n\n\n\nA relation \n is an equivalance realtion iff it is reflexive, symetric and transitive.\n\n\nEquivalnce classes\n\n\nLet \n be an equivalence realtion on a set \n and \n let \n be the equivalence class of a w.r.t \n.\n\n\nIf \n the \n is called a representative of the equivalance class.\n\n\nLet \n be an equivalnce realtion on \n amd \n. Then following statements are equivalnet\n\n\n\n\n\n\n\n\n\n\n\n\nPartitions of a Set\n\n\nA partition of set \n is a collection of disjoint, nonempty subsets that have \n as their union, in other words the collection of subsets \n with \n (where \n is the index set) forms a partition of \n iff\n\n\n\n\n for all \n\n\n for all \n\n\nERROR\n\n\n\n\nTODO: finish this\n\n\nSequences\n\n\n\n\nSequence\n\n\nOrdered list of elements\n\n\n\n\n is \n defines the sequence \n\n\n\n\nGeometric progressions\n\n\nA sequence in the form \n\n\nArithmetic progressions\n\n\nA sequence in the form \n\n\n\n\nRecurrence relations\n\n\n\n\nRecurrence relations\n\n\nA recurance relations for \n is an equation that expreses \n in terms of one or more elements of \n\n\n\n\n\n\nAfter 1 month a pair of rabbits is placed on an island\n\n\nAfter every 2 months, each pair of rabbits produces a new pait of rabbits \n\n\n\n\nThe realtion is:\n\nERROR\n\n\nSolving a recurrence relations if finding the nth term, one way of solving is an inteative aproach\n\n\n\n\nSupose a person deposits $1000 in savings with 3 percent intrest, how much is the account worth after 20 years\n- Let \n denote the amount after \n years\n- \n\n- \n\n- \n\n\n\n\nCommon sequences\n\n\n| nth term | first 10 terms |\n| \n ||\n| \n ||\n| \n ||\n| \n ||\n| \n ||\n| \n ||\n| \n ||\n\n\nSumations\n\n\nGiven a sequence \n, the sum of the terms is \n or \n\n\nUsefull sumations\n\n\nProduct\n\n\nGiven a sequence \n, the product of the terms i s\n or \n, or more generally for a finite index set \n, \n\n\nCartinality\n\n\n\n\nTwo sets have the same cardinality \n iff there is an bijection \n\n\n iff there is an injection \n\n\nUnlike finite sets \n and \n\n\n\n\nTODO: example",
            "title": "Discrete Mathmatics and Mathmatical Reasoning"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#propositonal-logic",
            "text": "",
            "title": "Propositonal Logic"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#propositions",
            "text": "Proposition  A declarative sentence (declares a fact) that is either true or false.      Propositon  Not propositions      It is raining.  What is the data?",
            "title": "Propositions"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-operators",
            "text": "From these propositions we can from new compound propositions with logical operators:     Operation  Example  Explanation      Negation   it is not the case that     Conjunction   both   and   must be true for   to be true    Disjunction   False when both   and   are false, true otherwise    Exclusive Or   Either   or   must be true ( not both ) for   to be true    Implication   False when   is true and   is false, true otherwise.   is the hypothesis/antecedent and   is the conclusion/conseqence    Biconditional    if and only if  , true when both   and   have the same truth values",
            "title": "Logical operators"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#truth-tables",
            "text": "With these logical operators we can build complex logical statements such as:  . To construct truth tables for these expressions we start with the individual variables   and  , and solve sub expressions until we reach the full expression.",
            "title": "Truth tables"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#operator-precedence",
            "text": "The order of which operators apply are as follows:     Operator  Precedence       1     2     3     4     5",
            "title": "Operator precedence"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-equivalences",
            "text": "Tautology  A compound proposition that is  true , no matter what values the propositional variables hold.  Contradiction  A compound proposition that is  false , no matter what values the propositional variables hold.  Contingency  Compound propositions that are neither a tautology or a contradiction.     is a tautology   is a contradiction   is a contingency   Two compound propositions are  logically equivilent  if they have the same truth values in all cases. This occors when   is a tautology, where   and   are compound propositions.   is a statement, denoting that   and   are logically equivilent.",
            "title": "Logical Equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#important-equivalences",
            "text": "Equivalence  Name       Identity laws     Domination laws     Idempotent laws     Double negation law     Commutative laws     Associative laws     Distributive laws     De Morgan's laws     Absorption laws     Negation laws     Logical equivalences involving conditional statements     Logical equivalences involving biconditionals",
            "title": "Important Equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#notation",
            "text": "Simular to  , their exsists a notation for   and  .",
            "title": "Notation"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#constructing-new-logical-equivalences",
            "text": "Using equivalences we already know, we can prove expressions are tautologys or that two expressions are logically equivelent. While a truth table could also be used, it is much shorted to apply laws.   Show that   is a tautology.",
            "title": "Constructing new logical equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#satisfaction",
            "text": "Satisfiable  A compound proposition were there  is a  assignment of truth values that make it true.  Unsatisfiable  A compound proposition were there  is no  assignment of truth values that make it true.   The values which make a compound proposition true is called the  solution to the satisfiability problem .",
            "title": "Satisfaction"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#predicates-and-quantifiers",
            "text": "",
            "title": "Predicates and Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#predicates",
            "text": "Statements that involve variables such as   and   are undecided when their variables are not given a value. We need a more powerfull logic,  predicate logic , to model these statements.  We turn the statement   into the predicate   where   is  . When we give   a value, the statement becomes a proposition, e.g.   becomes   which is  .  A predicate can have any number of variables,  . A predicate with   variables is called an  -ary predicate.",
            "title": "Predicates"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#quantifiers",
            "text": "Assigning variables is not the only way to form a proposition from a predicate.  Quantification  expresses the extend to which a predicate is true over a range.     Name  Example  Note      Universal quantifier   is true if   is true for all x (domain)    Existential quantifier   is true if   is true for at least one value in the domain      Is   where the domain is all real numbers true.  No, if  ,  ) is false, thus not all elements in the domain make   true.",
            "title": "Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#restricting-the-domain",
            "text": "Consider   where the domain of   is  . We could express that as:   Their is a shorter notation for restricting the domain",
            "title": "Restricting the domain"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#precedence-of-quantifiers",
            "text": "and   have a higher precedence that all other logical operators.",
            "title": "Precedence of Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#binding-variables",
            "text": "When a quantifier is used on variable, or the variable is assigned a value, the variable is said to be  bound . Predicates must have all the variables bound to be turned into a proposition. Variables that are not bound are  free .  The  scope  of a quantifier is the part of the logical expression to which it is applied, hence variables outside of the scope of all quantifiers are free (if their value has not been assigned).",
            "title": "Binding Variables"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-equivalence",
            "text": "Two expressions involving predicates and quantifiers are equal if their truth values are the same throughout the domain.   Show that   and   are logically equivalent.   Let   be some element in the domain, thus   must be  .  If   is  ,   and   must both be  .  Since   and   are   for all element in the domain,   must also be $\\top$.   So",
            "title": "Logical Equivalence"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#negation",
            "text": "Statement  Equivalent  Note        Their is an   for which   is       For every  ,   is       Prove     is  , if and only if   is   If   is  , then their is atleast one element in the domain for which   is true.  It follows then the",
            "title": "Negation"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#nested-quantifiers",
            "text": "More complex statements often involve more than one quantifier. For example the logical statement that  if   is positive and   is negative,   is negative  can be expressed as:",
            "title": "Nested Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#proof",
            "text": "",
            "title": "Proof"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#rules-of-inference",
            "text": "Proofs are mathmatical arguments that determine the truth of a statement.  By an argument , means a sequence of statements that end in a conclusion.  By valid , means the conclusion must follow from the arguments.  By premise , means the argument is valid if and only if it is impossible for all premises to be true and the conclusion false.  An  argument  is propositional logic is a sequence of propositons, where the final proposition is the conclusion and all others are the premises. An  argument form  in propositional logic is a sequence of compound propositions that is  valid  no matter what propositions are substitude for a premise, so long as the premises are true.  The  modus ponens  (law of detachment) is one rule we can use to proof statements.    Let   be \"it snows\" and   be \"will go skiing\", if \"we will go skiing if it snows\" is \"we will go skiing\" true?       Rule of Inference  Tautology  Name        Modus ponens      Modus tollens      Hypothetical syllogism      Disjunctive syllogism      Addition      Simplification      Conjunction      Resolution",
            "title": "Rules of Inference"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#using-rules-of-inference-to-build-arguments",
            "text": "Given the premesis:  ,  ,  ,   find an argument that shows the premisies lead to the conclusion  .",
            "title": "Using Rules of Inference to Build Arguments"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#fallacies",
            "text": "is a tautology, fallacies often look like tautologys but are just contingencies:   Fallacy of affirming the conclusion  occors when   is treated as a tautology, but it is false when   is false and   is true.  Fallacy of denying the hypothesis  occors when   is treated as a tautology, but it is false when   is false and   is true.",
            "title": "Fallacies"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#rules-of-inference-for-quantified-statements",
            "text": "Rule of Inference  Name  Notes       Universal instantiation   is true, where   is an element of the domain, since all elements are true.     Universal generalization   is true, if   (where   is an arbitary element in the domain) is true. Since we do not make any assumptions about  , other than its an element of the domain, all values of the domain must be true.     Existential instantiation  Their is an element   in the domain that makes   true. Note   is not arbitary since some elements in the domain do not make   true.     Existential generalization  If we know one element   in the domain that makes   true, then it follows that       Show that the premesis \"A student in the class has not read the book\" and \"Everyone in the class passed the exam\" implys the conclusion that \"Someone who passed the exam had not read the book\"   Let   be \"  is in the class\"  Let   be \"  passed the exam\"  Let   be \"  has read the book\"",
            "title": "Rules of Inference for Quantified Statements"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set",
            "text": "An unordered collection of elements",
            "title": "Set"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set-operations",
            "text": "Name  Example      Equality     Membership     Non-Membership     Empty Set     Union     Intersection     Diffrence     Complement     Subset     Superset     Power Set   (set of all subsets)    Cardinality     Cartesian Product",
            "title": "Set Operations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#common-sets",
            "text": "Name  Symbol  Description      Booleans      Natural numbers      Integer      Positive Integers      Real Numbers      Rational      Complex Numbers",
            "title": "Common Sets"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set-identitys",
            "text": "",
            "title": "Set Identitys"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#syntax",
            "text": "A function   from set   to set   assigns an element from   to  , this is written as  .  Examples:   Ceil -   Floor -   Identity -   Factorial -",
            "title": "Syntax"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#injective",
            "text": "iff   For every element in A their is an element in B which maps to it.  Examples:   Identity function",
            "title": "Injective"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#surjective",
            "text": "is surjective iff   For every element in B, their is an element in A which is mapped onto it.  Examples:   Identity function   for",
            "title": "Surjective"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#one-to-one-correspondence-or-bijection",
            "text": "is a bijection iff it is both injective and bijective  Every element in the domain is mapped to a value in the range and visa-versa.  Examples   Identity function",
            "title": "One-to-one correspondence or bijection"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#composition",
            "text": "Let   and  . The composition function   is    The composition of two functions is a function  The composition of two injective functions is a injective function  The composition of two surjective functions is a surjective function  The composition of two bijections is a bijection",
            "title": "Composition"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#inverse",
            "text": "If   is a bijection, then the inverse of  , written   is   iff    Inverse of the identity function, is the identity function  Inverse of   is      and   is the identity function",
            "title": "Inverse"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#relations",
            "text": "A binary relation   on sets   and   is a subset    Often written as   for   A function   is a restricted relation where   For all a in   their exsists a   in   where (a, b) in relation   and   is unique      Given sets   a subset   is an  -ary relation.    where   is students and   is courses,",
            "title": "Relations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#operations",
            "text": "Relations are sets, so we can use the same operations, i.e.   or",
            "title": "Operations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#realtion-composition",
            "text": "Let   and  . The composition relation   is   The expression specifys the relations where   and   have a common  , thus   Closure   is a relation on  :    is the identity relation",
            "title": "Realtion composition"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#graph-reachability",
            "text": "",
            "title": "Graph reachability"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#properties",
            "text": "Reflexive iff  .  ,   and   are reflexive, but   is not.  Symetic iff  .   is symmetic, but  ,   and   are not.  antisymetic iff  .  ,  ,   are antisymmetic but   is not.  transitive iff  .  ,  ,   and   are transitive.   A relation   is an equivalance realtion iff it is reflexive, symetric and transitive.",
            "title": "Properties"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#equivalnce-classes",
            "text": "Let   be an equivalence realtion on a set   and   let   be the equivalence class of a w.r.t  .  If   the   is called a representative of the equivalance class.  Let   be an equivalnce realtion on   amd  . Then following statements are equivalnet",
            "title": "Equivalnce classes"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#partitions-of-a-set",
            "text": "A partition of set   is a collection of disjoint, nonempty subsets that have   as their union, in other words the collection of subsets   with   (where   is the index set) forms a partition of   iff    for all    for all   ERROR",
            "title": "Partitions of a Set"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#todo-finish-this",
            "text": "",
            "title": "TODO: finish this"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#sequences",
            "text": "Sequence  Ordered list of elements    is   defines the sequence    Geometric progressions  A sequence in the form   Arithmetic progressions  A sequence in the form",
            "title": "Sequences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#recurrence-relations",
            "text": "Recurrence relations  A recurance relations for   is an equation that expreses   in terms of one or more elements of     After 1 month a pair of rabbits is placed on an island  After every 2 months, each pair of rabbits produces a new pait of rabbits    The realtion is: ERROR  Solving a recurrence relations if finding the nth term, one way of solving is an inteative aproach   Supose a person deposits $1000 in savings with 3 percent intrest, how much is the account worth after 20 years\n- Let   denote the amount after   years\n-  \n-  \n-",
            "title": "Recurrence relations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#common-sequences",
            "text": "| nth term | first 10 terms |\n|   ||\n|   ||\n|   ||\n|   ||\n|   ||\n|   ||\n|   ||",
            "title": "Common sequences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#sumations",
            "text": "Given a sequence  , the sum of the terms is   or",
            "title": "Sumations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#usefull-sumations",
            "text": "",
            "title": "Usefull sumations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#product",
            "text": "Given a sequence  , the product of the terms i s  or  , or more generally for a finite index set  ,",
            "title": "Product"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#cartinality",
            "text": "Two sets have the same cardinality   iff there is an bijection    iff there is an injection   Unlike finite sets   and",
            "title": "Cartinality"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#todo-example",
            "text": "",
            "title": "TODO: example"
        },
        {
            "location": "/Introduction-to-Computer-Systems/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nFloating point\n\n\n\n\nMantissa/significand\n\n\nFractional part\n\n\nExponent\n\n\nPower of $2$\n\n\n\n\n\n\nConvert $25_{10}$ in floating point form\n\n\n$25_{10} = 011001_2$\n\n\n$1.1001 \\times 2^4$\n\n\n\n\nWhy normalize?\n\n\n\n\nSimplifiys machine representation\n\n\nSimplifys comparisons e.g. $0.00000101$ vs $0.000001$\n\n\nMore compact for small/large numbers\n\n\n\n\nIEEE 654 Floating Point Standard\n\n\n\n\n1'st bit is sign bit ($s$)\n\n\n8 bits for exponent ($exp$)\n\n\nrest for mantissa ($m$)\n\n\n\n\nEncoding:\n$s \\times m \\times 2 ^ {exp - 127}$\n\n\n(127 is the \nbias\n)\n\n\n$0.75_{10} = 0.11_2 = {(1.1 \\times 2^{-1})}_2$\n\n\nWhy bias?\n\n\n\n\nExponent can always be positive (no need to store sign bit)\n\n\nSimplifys comparison operations\n\n\n\n\nSpecial values\n\n\n\n\n\n\n\n\nExponenent\n\n\nMantisa\n\n\nNumber\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n1-254\n\n\nAnything\n\n\nFloating point number\n\n\n\n\n\n\n255\n\n\n0\n\n\nInfinity (signed)\n\n\n\n\n\n\n255\n\n\nnon-zero\n\n\nNaN (not a number)\n\n\n\n\n\n\n\n\nMIPS\n\n\n\n\nISA\n\n\nInstruction set architecture - The interface between the hardware and the software\n\n\nMIPS\n\n\nA real world ISA used by many diffrent processors since the 80s\n\n\n\n\nInstruction set\n\n\n\n\nAssemble Language\n\n\nSymbolic representation of machine instructions.\n\n\n\n\nMachine code are instructions stored as binary values, assembly language is a one-to-one mapping that allow human programmers to reason about programs.\n\n\nHigh level:\n\n\na[0] = b[0] + 10\n\n\n\n\nMIPS:\n\n\nlw r4, 0(r2)    # Load word - Get the value fo b[0] from memory and store in r4\nadd r5,r4,10    # Add - Compute b[0]+10 and store in r5\nsw r5,0(r1)     # Save word - Store r5 into a[0]\n\n\n\n\nMIPS does not allow accessing and operating on data at the same time\n\n\nArithmatica and Logical Operations\n\n\n\n\nadd a, b, c\n $a = b + c$\n\n\nsub a, b, c\n $a = b - c$\n\n\nsll a, b, c\n $a = b << c$\n\n\nsrl a, b, c\n $a = b >> c (logical)$\n\n\nsra a, b, c\n $a = b >> c (arithmatic)$\n\n\n\n\nRegister\n\n\n\n\nRegister\n\n\nStorage locations inside the processor that holds program variables and control state\n\n\n\n\nMIPS instruction\n\n\nEach assemby instruction translates into 1 machine instruction as shown bellow:\n\n\n\n\n\n\n\n\n\n\nMain opcode\n\n\n1\nst\n operand\n\n\n2\nnd\n operand\n\n\nresult\n\n\nshift\n\n\nsub-function opcode\n\n\n\n\n\n\n\n\n\n\n\n\nop\n\n\nrs\n\n\nrt\n\n\nrd\n\n\nshamt\n\n\nfunc\n\n\n\n\n\n\nadd $s1, $s2, $s3\n\n\n0\n\n\n18\n\n\n19\n\n\n17\n\n\n0\n\n\n$32_{10}$\n\n\n\n\n\n\nsub $t0, $s2, $t1\n\n\n0\n\n\n18\n\n\n9\n\n\n8\n\n\n0\n\n\n$34_{10}$",
            "title": "Introduction to Computer Systems"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#floating-point",
            "text": "Mantissa/significand  Fractional part  Exponent  Power of $2$    Convert $25_{10}$ in floating point form  $25_{10} = 011001_2$  $1.1001 \\times 2^4$",
            "title": "Floating point"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#why-normalize",
            "text": "Simplifiys machine representation  Simplifys comparisons e.g. $0.00000101$ vs $0.000001$  More compact for small/large numbers",
            "title": "Why normalize?"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#ieee-654-floating-point-standard",
            "text": "1'st bit is sign bit ($s$)  8 bits for exponent ($exp$)  rest for mantissa ($m$)   Encoding:\n$s \\times m \\times 2 ^ {exp - 127}$  (127 is the  bias )  $0.75_{10} = 0.11_2 = {(1.1 \\times 2^{-1})}_2$",
            "title": "IEEE 654 Floating Point Standard"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#why-bias",
            "text": "Exponent can always be positive (no need to store sign bit)  Simplifys comparison operations",
            "title": "Why bias?"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#special-values",
            "text": "Exponenent  Mantisa  Number      0  0  0    1-254  Anything  Floating point number    255  0  Infinity (signed)    255  non-zero  NaN (not a number)",
            "title": "Special values"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#mips",
            "text": "ISA  Instruction set architecture - The interface between the hardware and the software  MIPS  A real world ISA used by many diffrent processors since the 80s",
            "title": "MIPS"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#instruction-set",
            "text": "Assemble Language  Symbolic representation of machine instructions.   Machine code are instructions stored as binary values, assembly language is a one-to-one mapping that allow human programmers to reason about programs.  High level:  a[0] = b[0] + 10  MIPS:  lw r4, 0(r2)    # Load word - Get the value fo b[0] from memory and store in r4\nadd r5,r4,10    # Add - Compute b[0]+10 and store in r5\nsw r5,0(r1)     # Save word - Store r5 into a[0]  MIPS does not allow accessing and operating on data at the same time",
            "title": "Instruction set"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#arithmatica-and-logical-operations",
            "text": "add a, b, c  $a = b + c$  sub a, b, c  $a = b - c$  sll a, b, c  $a = b << c$  srl a, b, c  $a = b >> c (logical)$  sra a, b, c  $a = b >> c (arithmatic)$",
            "title": "Arithmatica and Logical Operations"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#register",
            "text": "Register  Storage locations inside the processor that holds program variables and control state",
            "title": "Register"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#mips-instruction",
            "text": "Each assemby instruction translates into 1 machine instruction as shown bellow:      Main opcode  1 st  operand  2 nd  operand  result  shift  sub-function opcode       op  rs  rt  rd  shamt  func    add $s1, $s2, $s3  0  18  19  17  0  $32_{10}$    sub $t0, $s2, $t1  0  18  9  8  0  $34_{10}$",
            "title": "MIPS instruction"
        },
        {
            "location": "/Introduction-to-Software-Engineering/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nUse Cases\n\n\n\n\nUse case\n\n\nA task involving the system which has value for one or more stakeholders.\n\n\nActors\n\n\nA stakeholder who takes an active part in the use case.\n\n\nPrimary Actor\n\n\nStakeholder with primary intrest in use case (usually the one triggering the use case).\n\n\nSupporting actors\n\n\nActors also envolved\n\n\n\n\nSome stakeholders may not be participating in a use case (so neither primary or supporting actors).\n\n\nActors can be:\n\n\n\n\nUsers of a system\n\n\nAn external system, which interacts with the system\n\n\n\n\nUsually a use case is a sequence of steps, however they may other paths, they may succeed, fail, or succeed in an alternate way.\n\n\nExample\n\n\nMain success scenario\n\n\n1. Customer selects item\n2. Customer checks out\n3. ...\n4. Email confirmation\n\n\n\n\nExtensions - variations of the main success scenario\n\n\n6a. Credit card auth fails\n    .1 Re-enter details\n\n\n\n\nUse case templates\n\n\n\n\nGoal:\n What the primary actor wishes to acheive\n\n\nSummary:\n Description of use case\n\n\nStakeholders and each\u2019s Interest in the use case\n\n\nPrimary actor\n\n\nSupporting actors\n\n\nTrigger:\n The event that leads to this use case being performed.\n\n\nPre-conditions/Assumptions:\n What can be assumed to be true when the use case starts\n\n\nGuarantees:\n What the use case ensures at its end\n\n\nSuccess guarantees\n\n\nFailure guarantees\n\n\nMinimal guarantees\n\n\n\n\n\n\nMain Success Scenario\n\n\nAlternative scenarios\n\n\n\n\nA use case can:\n- Diffrent levels of detail\n    - Depending on part of development process\n- May refer to other use cases\n- Descripe diffrent scopes\n\n\nRequirements capture\n\n\n\n\nIdentify actors\n\n\nFor each actor\n\n\nWhat do they need\n\n\nAny other expected interactions\n\n\nWhich use cases have priority\n\n\n\n\n\n\n\n\nUse cases are often functional requirements, with non-functional requirements attached. Other times. Non-functional requirements apply to subsets or all of use-cases.\n\n\nOther uses\n\n\n\n\nDrive design\n\n\nDesign validation\n\n\nDoes the design work\n\n\n\n\n\n\nTesting\n\n\nGood source for system tests\n\n\n\n\n\n\n\n\nProblems\n\n\n\n\nMay be to much detail (constraining design)\n\n\nSupporting actors may not be strictly necessary i.e. librarian may not be involved in borrowing a book (in a modern library)\n\n\nLess attension to architecture and static object structure.\n\n\nMay miss requirements not associated with actors.\n\n\n\n\nDesign\n\n\n\n\nDesign\n\n\nHow softawre will meet the requirements\n\n\n\n\nOutputs of design:\n\n\n\n\nModels\n\n\nUML / SImulink\n\n\nOften graphical\n\n\nCan be executable\n\n\n\n\n\n\nWritten documents\n\n\nRecord reasons for decisions (\n\n\ntrace back when problem occors to relevent stakeholder\n\n\n\n\n\n\n\n\nCriteria:\n\n\n\n\nThe design can meet the requirements\n\n\nIs it maintainable?\n\n\nCan it be explained to implementors\n\n\nFits constraints of exsisting technology (legacy components)\n\n\nMakes future design choices easy\n\n\n\n\n\n\nHigh level (architectural) design\n\n\nHow subsytems are split up\n\n\nLow level (detailed) design\n\n\nHow subsystems are composed\n\n\n\n\nAt each level:\n\n\n\n\nWhat are the responsibilities of each component?\n\n\nwhat are the interfaces?\n\n\nWhat are the messages exchanged (what protocols)?\n\n\n\n\n\n\nArchitecture\n\n\nThe way that components work together.\n\n\n\n\n\n\n\n\nWhat are the components\n\n\n\n\nWhere shall we put the encapsulation barriers?\n\n\nWhich decisions do we want to hide inside components (so they can be changed without effecting the rest of the system)?\n\n\n\n\n\n\n\n\nWhat are the connectors?\n\n\n\n\nHow/what do the components need to communicate?\n\n\nWhat should be the interfaces?\n\n\nWhat protocols should be used?\n\n\n\n\n\n\n\n\nMore architecutral decisions:\n\n\n\n\nWhat language and/or component standard is going to be used?\n\n\nIs their an appropriate exising framework?\n\n\nWhat conventions for error handling?\n\n\nbackups\n\n\nresiliance\n\n\nfail gracefully\n\n\n\n\n\n\n\n\nDetailed design\n\n\n\n\nArchitecture has be designed\n\n\nEach person/team is in charge of designing one subsystem\n\n\nWhat external interfaces must it work with?\n\n\nWhat classes and behaviour are needed?\n\n\nCoordination with system architect to change interface if required.\n\n\n\n\nPrinciples\n\n\n\n\nCohesion\n\n\nA mesure of the strenth o fthe realationship between the pieces of functionality within the component. High cohesion has increased understandability, maintainability and reliability.\n\n\nCoupling\n\n\nA mesure of the strength of the inter-connection between components. Loose coupling increases understandability and maintainablilty.\n\n\nAbstraction\n\n\nA view of some entity that focuses on the infomation relevent to a particular purpose.\n\n\nEncapsulation\n\n\nGrouping and packaging the elements and internal details of an abstraction and making those details inaccessible.\n\n\nSeperation of interface/implementation\n\n\nSpecifing a public interface, known to the clients, separate from the details of how the component is realized.\n\n\nDecomposition\n\n\nDivinding large systems into smaller components with distinct responsibilitys.\n\n\n\n\nModeling\n\n\n\n\nModel\n\n\nA precise represntation of some of the information needed to solve a problem using a computer.\n\n\n\n\nA UML model\n- represented by set of diagrams\n- structured represnetation too (XML)\n- must obey rules of UML standard\n- (fairly) precise meaning\n- Used informally (talking around whiteboard)\n\n\nBig design up front\n\n\n\n\nOften unavoidable\n\n\nIf done right, simplifys developent\n\n\nError prone (changing requirements)\n\n\nWastefull (mistakes in requirements)\n\n\n\n\nXP maxinms:\n- You aint going to need it\n- Do the simplest thing that could possibly work",
            "title": "Introduction to Software Engineering"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#use-cases",
            "text": "Use case  A task involving the system which has value for one or more stakeholders.  Actors  A stakeholder who takes an active part in the use case.  Primary Actor  Stakeholder with primary intrest in use case (usually the one triggering the use case).  Supporting actors  Actors also envolved   Some stakeholders may not be participating in a use case (so neither primary or supporting actors).  Actors can be:   Users of a system  An external system, which interacts with the system   Usually a use case is a sequence of steps, however they may other paths, they may succeed, fail, or succeed in an alternate way.",
            "title": "Use Cases"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#example",
            "text": "Main success scenario  1. Customer selects item\n2. Customer checks out\n3. ...\n4. Email confirmation  Extensions - variations of the main success scenario  6a. Credit card auth fails\n    .1 Re-enter details",
            "title": "Example"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#use-case-templates",
            "text": "Goal:  What the primary actor wishes to acheive  Summary:  Description of use case  Stakeholders and each\u2019s Interest in the use case  Primary actor  Supporting actors  Trigger:  The event that leads to this use case being performed.  Pre-conditions/Assumptions:  What can be assumed to be true when the use case starts  Guarantees:  What the use case ensures at its end  Success guarantees  Failure guarantees  Minimal guarantees    Main Success Scenario  Alternative scenarios   A use case can:\n- Diffrent levels of detail\n    - Depending on part of development process\n- May refer to other use cases\n- Descripe diffrent scopes",
            "title": "Use case templates"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#requirements-capture",
            "text": "Identify actors  For each actor  What do they need  Any other expected interactions  Which use cases have priority     Use cases are often functional requirements, with non-functional requirements attached. Other times. Non-functional requirements apply to subsets or all of use-cases.",
            "title": "Requirements capture"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#other-uses",
            "text": "Drive design  Design validation  Does the design work    Testing  Good source for system tests",
            "title": "Other uses"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#problems",
            "text": "May be to much detail (constraining design)  Supporting actors may not be strictly necessary i.e. librarian may not be involved in borrowing a book (in a modern library)  Less attension to architecture and static object structure.  May miss requirements not associated with actors.",
            "title": "Problems"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#design",
            "text": "Design  How softawre will meet the requirements   Outputs of design:   Models  UML / SImulink  Often graphical  Can be executable    Written documents  Record reasons for decisions (  trace back when problem occors to relevent stakeholder     Criteria:   The design can meet the requirements  Is it maintainable?  Can it be explained to implementors  Fits constraints of exsisting technology (legacy components)  Makes future design choices easy    High level (architectural) design  How subsytems are split up  Low level (detailed) design  How subsystems are composed   At each level:   What are the responsibilities of each component?  what are the interfaces?  What are the messages exchanged (what protocols)?    Architecture  The way that components work together.     What are the components   Where shall we put the encapsulation barriers?  Which decisions do we want to hide inside components (so they can be changed without effecting the rest of the system)?     What are the connectors?   How/what do the components need to communicate?  What should be the interfaces?  What protocols should be used?",
            "title": "Design"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#more-architecutral-decisions",
            "text": "What language and/or component standard is going to be used?  Is their an appropriate exising framework?  What conventions for error handling?  backups  resiliance  fail gracefully",
            "title": "More architecutral decisions:"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#detailed-design",
            "text": "Architecture has be designed  Each person/team is in charge of designing one subsystem  What external interfaces must it work with?  What classes and behaviour are needed?  Coordination with system architect to change interface if required.",
            "title": "Detailed design"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#principles",
            "text": "Cohesion  A mesure of the strenth o fthe realationship between the pieces of functionality within the component. High cohesion has increased understandability, maintainability and reliability.  Coupling  A mesure of the strength of the inter-connection between components. Loose coupling increases understandability and maintainablilty.  Abstraction  A view of some entity that focuses on the infomation relevent to a particular purpose.  Encapsulation  Grouping and packaging the elements and internal details of an abstraction and making those details inaccessible.  Seperation of interface/implementation  Specifing a public interface, known to the clients, separate from the details of how the component is realized.  Decomposition  Divinding large systems into smaller components with distinct responsibilitys.",
            "title": "Principles"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#modeling",
            "text": "Model  A precise represntation of some of the information needed to solve a problem using a computer.   A UML model\n- represented by set of diagrams\n- structured represnetation too (XML)\n- must obey rules of UML standard\n- (fairly) precise meaning\n- Used informally (talking around whiteboard)",
            "title": "Modeling"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#big-design-up-front",
            "text": "Often unavoidable  If done right, simplifys developent  Error prone (changing requirements)  Wastefull (mistakes in requirements)   XP maxinms:\n- You aint going to need it\n- Do the simplest thing that could possibly work",
            "title": "Big design up front"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nClosure Properties of Regular Languages\n\n\n-NFA\n\n\nIf we allow \n transitions, which represents an instananious transition, NFA's can be transformed to have one start and one accepting state.\n\n\nThis doesnt increase the power of NFA's, but it has some convenience.\n\n\nConcatination\n\n\n\n\n is the concatination of two languages, for example \n, \n becomes \n\n\nIts obvious the concatination is closed, since we can add an \n transition between the start and accepting states of the machines for languages \n and \n\ns\n\n\nKleene star\n\n\n\n\n Is the langauge of 0 or more strings of \n\n\nAgain kleene start is also closed. By introducing a new start state (which is also an accepting state) with an \n transition to the machine for \n and add \n transitions back from the machine to the new start/accepting state. This allows the machine for \n to run for any amount of times.\n\n\nRegular Expressions\n\n\nRegular expressions are a language for defining languages.\n\n\n\n\n\n\n\n\nSymbol\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n (for \n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder\n\n\nIn the absence of brackets the order of operation is as follows:\n\n\n\n\n\n\n\n\n\n\n\n\nKleene's Theorem\n\n\nKleene's Theorem:\n DFA's and regular expressions give rise to exactly the same class of langauges (the regular langauges)\n\n\nSo regular languages can be defined as regular expressions.\n\n\nKleene algebra\n\n\nRegular expressions can be manipulated with kleene algebra without changing the language\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n\nArdens rule\n\n\nGiven an equation of the form \n its smallest solution is \n. If \n, this is the only solution\n\n\nDFA's to regular expressions\n\n\nFor each state \n, the variable \n stands for the set of states that take us from \n to the accepting state.\n\n\n\n\nApplications of regular languages\n\n\nGrep\n\n\nSearch for prices in pounds and pence:\n\n\ngrep \"[0-9]*\\.[0-9][0-9]\" document.txt\n\n\n\n\n\n\nfgrep\n searches for one or more fixed string, using an efficent string matching algorthum\n\n\ngrep\n searches for strings matching a pattern\n\n\negrep\n searches for strings matching an extended pattern\n\n\n\n\nString searching\n\n\nSupose we want to search for string \n in document \n. An efficent implentation is the Knuth-Morris-Pratt algorithum:\n\n\n\n\nConvert NFA accepting \n     to DFA M (costs some time, worth it for short \n and long \n).\n\n\nRun \n through \n (each character in \n processed once, no buffering).\n\n\nEvery time we get to the accepting state of \n, signal a hit.\n\n\n\n\nThis can be extended to search for mulitple strings in parralel with a more complex NFA.\n\n\nPattern searching\n\n\negrep\n will print all lines containing a match.\n\n\n\n\nWe can convert a pattern into a (smallish) NFA.\n\n\nWe can run the NFA using the just-in-time simulation (avoids exponential state-space blow-up).\n\n\n\n\nData validation\n\n\n\n\nWithin XML we can enforce constraints on parts of the data.\n\n\nFor text fields on web froms, we can check if the input text is in the correct form.\n\n\n\n\nLexing\n\n\nEven tough a higher level language is to complex to be regular, regular expressions can be used to identify the fundemental building blocks (tokens) of the language.\n\n\n\n\nLexical Analysis\n\n\nBreaking up source code into a series of tagged tokens (lexemes)\n\n\nLexical class\n\n\nThe class of a token, for example \n1000\n would be an integer literal, \nfoobar\n would be an identifier.\n\n\n\n\nHow lexers work\n\n\n\n\nBuild NFA's for the lexical classes \n (in order of priority)\n\n\nRun the 'parrallel' automaton \n until it expires\n\n\nThe last point in which we were in an accepting state is the largest match, chose the smallest \n such that were in an accepting state of \n. Chose class \n as the lexical class for \n which is the highest priorty.\n\n\nPerform the specified action for the class \n\n\n\n\nVerification\n\n\nRegulare langauge theory can help verify desirable properites:\n\n\n\n\nSaftey, i.e. \nbad things dont happen\n\n\nLiveness, i.e. \ngood things do happen\n\n\nFierness, i.e. \nthings good for some processes dont cause to much badness to others\n\n\n\n\nExample\n\n\nSuppose we have two processes \n that have use of a shared resource, but must not be given access at the same time.\n\n\n can comunicate using three shared flags\n- \nreq0\n initially false, whether \n wants access\n- \nreq1\n initially false, whether \n wants access\n- \nturn\n who is being allowed a turn\n\n\nCode for \n when it wants access\n\n\nreq0 = true\nturn = 1\nwhile(req1 && turn == 1) WAIT\n// P0 can now access resource\nreq0 = false\n\n\n\n\nCode for \n is the same with \n swapped and \nreq0\n and \nreq1\nswapped.\n\n\nThis can be moddled by a finite state machine:\n\n\nThe language for the complete system can now be obtained:\n\n\nwhere \n is the interleaving of regular langauges.\n\n\nNow machine \n with 200 states can be built.\n\n\nNow we can verify\n- Mutual exclusion: \n and \n can never access simulaneously.\n- Progress",
            "title": "Processing Formal and Natural Languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#closure-properties-of-regular-languages",
            "text": "",
            "title": "Closure Properties of Regular Languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#-nfa",
            "text": "If we allow   transitions, which represents an instananious transition, NFA's can be transformed to have one start and one accepting state.  This doesnt increase the power of NFA's, but it has some convenience.",
            "title": "-NFA"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#concatination",
            "text": "is the concatination of two languages, for example  ,   becomes   Its obvious the concatination is closed, since we can add an   transition between the start and accepting states of the machines for languages   and  \ns",
            "title": "Concatination"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleene-star",
            "text": "Is the langauge of 0 or more strings of   Again kleene start is also closed. By introducing a new start state (which is also an accepting state) with an   transition to the machine for   and add   transitions back from the machine to the new start/accepting state. This allows the machine for   to run for any amount of times.",
            "title": "Kleene star"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#regular-expressions",
            "text": "Regular expressions are a language for defining languages.     Symbol  Definition               (for  )",
            "title": "Regular Expressions"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#order",
            "text": "In the absence of brackets the order of operation is as follows:",
            "title": "Order"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleenes-theorem",
            "text": "Kleene's Theorem:  DFA's and regular expressions give rise to exactly the same class of langauges (the regular langauges)  So regular languages can be defined as regular expressions.",
            "title": "Kleene's Theorem"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleene-algebra",
            "text": "Regular expressions can be manipulated with kleene algebra without changing the language     ...",
            "title": "Kleene algebra"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#ardens-rule",
            "text": "Given an equation of the form   its smallest solution is  . If  , this is the only solution",
            "title": "Ardens rule"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#dfas-to-regular-expressions",
            "text": "For each state  , the variable   stands for the set of states that take us from   to the accepting state.",
            "title": "DFA's to regular expressions"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#applications-of-regular-languages",
            "text": "",
            "title": "Applications of regular languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#grep",
            "text": "Search for prices in pounds and pence:  grep \"[0-9]*\\.[0-9][0-9]\" document.txt   fgrep  searches for one or more fixed string, using an efficent string matching algorthum  grep  searches for strings matching a pattern  egrep  searches for strings matching an extended pattern",
            "title": "Grep"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#string-searching",
            "text": "Supose we want to search for string   in document  . An efficent implentation is the Knuth-Morris-Pratt algorithum:   Convert NFA accepting       to DFA M (costs some time, worth it for short   and long  ).  Run   through   (each character in   processed once, no buffering).  Every time we get to the accepting state of  , signal a hit.   This can be extended to search for mulitple strings in parralel with a more complex NFA.",
            "title": "String searching"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#pattern-searching",
            "text": "egrep  will print all lines containing a match.   We can convert a pattern into a (smallish) NFA.  We can run the NFA using the just-in-time simulation (avoids exponential state-space blow-up).",
            "title": "Pattern searching"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#data-validation",
            "text": "Within XML we can enforce constraints on parts of the data.  For text fields on web froms, we can check if the input text is in the correct form.",
            "title": "Data validation"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#lexing",
            "text": "Even tough a higher level language is to complex to be regular, regular expressions can be used to identify the fundemental building blocks (tokens) of the language.   Lexical Analysis  Breaking up source code into a series of tagged tokens (lexemes)  Lexical class  The class of a token, for example  1000  would be an integer literal,  foobar  would be an identifier.",
            "title": "Lexing"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#how-lexers-work",
            "text": "Build NFA's for the lexical classes   (in order of priority)  Run the 'parrallel' automaton   until it expires  The last point in which we were in an accepting state is the largest match, chose the smallest   such that were in an accepting state of  . Chose class   as the lexical class for   which is the highest priorty.  Perform the specified action for the class",
            "title": "How lexers work"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#verification",
            "text": "Regulare langauge theory can help verify desirable properites:   Saftey, i.e.  bad things dont happen  Liveness, i.e.  good things do happen  Fierness, i.e.  things good for some processes dont cause to much badness to others",
            "title": "Verification"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#example",
            "text": "Suppose we have two processes   that have use of a shared resource, but must not be given access at the same time.   can comunicate using three shared flags\n-  req0  initially false, whether   wants access\n-  req1  initially false, whether   wants access\n-  turn  who is being allowed a turn  Code for   when it wants access  req0 = true\nturn = 1\nwhile(req1 && turn == 1) WAIT\n// P0 can now access resource\nreq0 = false  Code for   is the same with   swapped and  req0  and  req1 swapped.  This can be moddled by a finite state machine:  The language for the complete system can now be obtained: \nwhere   is the interleaving of regular langauges.  Now machine   with 200 states can be built.  Now we can verify\n- Mutual exclusion:   and   can never access simulaneously.\n- Progress",
            "title": "Example"
        }
    ]
}