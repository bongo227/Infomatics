{
    "docs": [
        {
            "location": "/",
            "text": "Infomatics Notes",
            "title": "Home"
        },
        {
            "location": "/#infomatics-notes",
            "text": "",
            "title": "Infomatics Notes"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/",
            "text": "Propositonal Logic\n\n\nPropositions\n\n\n\n\nProposition\n\n\nA declarative sentence (declares a fact) that is either true or false.\n\n\n\n\n\n\n\n\n\n\nPropositon\n\n\nNot propositions\n\n\n\n\n\n\n\n\n\n\nIt is raining.\n\n\nWhat is the data?\n\n\n\n\n\n\n$\\pi = 1.23$\n\n\n$1 + x = 2$\n\n\n\n\n\n\n\n\nLogical operators\n\n\nFrom these propositions we can from new compound propositions with logical operators:\n\n\n\n\n\n\n\n\nOperation\n\n\nExample\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nNegation\n\n\n$\\neg p$\n\n\nit is not the case that $p$\n\n\n\n\n\n\nConjunction\n\n\n$p \\land q$\n\n\nboth $p$ and $q$ must be true for $p \\land q$ to be true\n\n\n\n\n\n\nDisjunction\n\n\n$p \\lor q$\n\n\nFalse when both $p$ and $q$ are false, true otherwise\n\n\n\n\n\n\nExclusive Or\n\n\n$p \\oplus q$\n\n\nEither $p$ or $q$ must be true (\nnot both\n) for $p \\oplus q$ to be true\n\n\n\n\n\n\nImplication\n\n\n$p \\rightarrow q$\n\n\nFalse when $p$ is true and $q$ is false, true otherwise. $p$ is the hypothesis/antecedent and $q$ is the conclusion/conseqence\n\n\n\n\n\n\nBiconditional\n\n\n$p \\leftrightarrow q$\n\n\n$p$ if and only if $q$, true when both $p$ and $q$ have the same truth values\n\n\n\n\n\n\n\n\nTruth tables\n\n\nWith these logical operators we can build complex logical statements such as: $(p \\lor q) \\rightarrow (p \\land q)$. To construct truth tables for these expressions we start with the individual variables $p$ and $q$, and solve sub expressions until we reach the full expression.\n\n\n\n\n\n\\begin{array}{c|c|c|c|c|c}\np & q & \\neg q & p \\lor \\neg q & p \\land \\neg q & (p \\lor q) \\rightarrow (p \\land q) \\\\ \\hline\n\\top & \\top & \\bot & \\top & \\top & \\top \\\\\n\\top & \\bot & \\top & \\top & \\bot & \\bot \\\\\n\\bot & \\top & \\bot & \\bot & \\bot & \\top \\\\\n\\bot & \\bot & \\top & \\top & \\bot & \\bot \\\\\n\\end{array}\n\n\n\n\n\n\n\n\nOperator precedence\n\n\nThe order of which operators apply are as follows:\n\n\n\n\n\n\n\n\nOperator\n\n\nPrecedence\n\n\n\n\n\n\n\n\n\n\n$\\neg$\n\n\n1\n\n\n\n\n\n\n$\\land$\n\n\n2\n\n\n\n\n\n\n$\\lor$\n\n\n3\n\n\n\n\n\n\n$\\rightarrow$\n\n\n4\n\n\n\n\n\n\n$\\leftrightarrow$\n\n\n5\n\n\n\n\n\n\n\n\nLogical Equivalences\n\n\n\n\nTautology\n\n\nA compound proposition that is \ntrue\n, no matter what values the propositional variables hold.\n\n\nContradiction\n\n\nA compound proposition that is \nfalse\n, no matter what values the propositional variables hold.\n\n\nContingency\n\n\nCompound propositions that are neither a tautology or a contradiction.\n\n\n\n\n\n\n$p \\lor \\neg p$ is a tautology\n\n\n$p \\land \\neg p$ is a contradiction\n\n\n$p \\lor q$ is a contingency\n\n\n\n\nTwo compound propositions are \nlogically equivilent\n if they have the same truth values in all cases. This occors when $p \\leftrightarrow q$ is a tautology, where $p$ and $q$ are compound propositions. $p \\equiv q$ is a statement, denoting that $p$ and $q$ are logically equivilent.\n\n\nImportant Equivalences\n\n\n\n\n\n\n\n\nEquivalence\n\n\nName\n\n\n\n\n\n\n\n\n\n\n$p \\land \\top  \\equiv p \\\\ p \\lor \\bot \\equiv p $\n\n\nIdentity laws\n\n\n\n\n\n\n$p \\lor \\top  \\equiv \\top \\\\ p \\land \\bot \\equiv \\bot $\n\n\nDomination laws\n\n\n\n\n\n\n$p \\lor p \\equiv p \\\\ p \\land p \\equiv p$\n\n\nIdempotent laws\n\n\n\n\n\n\n$\u00ac\u00acp \\equiv p$\n\n\nDouble negation law\n\n\n\n\n\n\n$p \\lor q \\equiv q \\lor p \\\\ p \\land q \\equiv q \\land p$\n\n\nCommutative laws\n\n\n\n\n\n\n$(p \\lor q) \\lor r \\equiv p \\lor (q \\lor r) \\lor p \\\\ (p \\land q) \\land r \\equiv p \\land (q \\land r) \\land p$\n\n\nAssociative laws\n\n\n\n\n\n\n$p \\lor (q \\land r) \\equiv (p \\lor q) \\land (p \\lor r) \\\\ p \\land (q \\lor r) \\equiv (p \\land q) \\lor (p \\land r)$\n\n\nDistributive laws\n\n\n\n\n\n\n$\u00ac(p \\land q) \\equiv \u00acp \\lor \u00acq \\\\ \u00ac(p \\lor q) \\equiv \u00acp \\land \u00acq$\n\n\nDe Morgan's laws\n\n\n\n\n\n\n$p \\lor (p \\land q) \\equiv p \\\\ p \\land (p \\lor q) \\equiv p$\n\n\nAbsorption laws\n\n\n\n\n\n\n$p \\lor \u00acp \\equiv \\top \\\\ p \\land \u00acp \\equiv \\bot$\n\n\nNegation laws\n\n\n\n\n\n\n$ p \\rightarrow q \\equiv \u00acp \\lor q \\\\ p \\rightarrow q \\equiv \u00acq \\rightarrow \u00acp \\\\ p \\lor q \\equiv \u00acp \\rightarrow q \\\\ p \\land q \\equiv \u00ac(p \\rightarrow \u00acq) \\\\ \u00ac(p \\rightarrow q) \\equiv p \\land \u00acq \\\\ (p \\rightarrow q) \\land (p \\rightarrow r) \\equiv p \\rightarrow (q \\land r) \\\\ (p \\rightarrow q) \\lor (p \\rightarrow r) \\equiv p \\rightarrow (q \\lor r) \\\\ (p \\rightarrow r) \\land (q \\rightarrow r) \\equiv (p \\lor q) \\rightarrow r \\\\ (p \\rightarrow r) \\lor (q \\rightarrow r) \\equiv (p \\land q) \\rightarrow r $\n\n\nLogical equivalences involving conditional statements\n\n\n\n\n\n\n$ p \\leftrightarrow q \\equiv (p \\rightarrow q) \\land (q \\rightarrow p) \\\\ p \\leftrightarrow q \\equiv \u00acp \\leftrightarrow \u00acq\\\\ p \\leftrightarrow q \\equiv (p \\land q) \\lor (\u00acp \\land \u00acq)\\\\ \u00ac(p \\leftrightarrow q) \\equiv p \\leftrightarrow \u00acq $\n\n\nLogical equivalences involving biconditionals\n\n\n\n\n\n\n\n\nNotation\n\n\nSimular to $\\sum$, their exsists a notation for $\\lor$ and $\\land$.\n\n\np_0 \\lor p_1 \\lor ... \\lor p_n \\equiv \\bigvee^n_{i = 0}p_i\n\n\n\n\np_0 \\land p_1 \\land ... \\land p_n \\equiv \\bigwedge^n_{i = 0}p_i\n\n\n\n\n\nConstructing new logical equivalences\n\n\nUsing equivalences we already know, we can prove expressions are tautologys or that two expressions are logically equivelent. While a truth table could also be used, it is much shorted to apply laws.\n\n\n\n\nShow that $(p \\land q) \\rightarrow (p \\lor q)$ is a tautology.\n\n\n\\begin{align}\n(p \\land q) \\rightarrow (p \\lor q) &\\equiv \u00ac(p \\land q) \\lor (p \\lor q) & \\\\\n                               &\\equiv (\u00acp \\lor \u00acq) \\lor (p \\lor q) &\\text{De Morgan's Law} \\\\\n                               &\\equiv (\u00acp \\lor p) \\lor (\u00acq \\lor q) &\\text{Assosiative and Commutative Law} \\\\\n                               &\\equiv \\top \\lor \\top &\\text{Negation Law} \\\\\n                               &\\equiv \\top &\\text{Domination Law}\n\\end{align}\n\n\n\n\n\n\n\nSatisfaction\n\n\n\n\nSatisfiable\n\n\nA compound proposition were there \nis a\n assignment of truth values that make it true.\n\n\nUnsatisfiable\n\n\nA compound proposition were there \nis no\n assignment of truth values that make it true.\n\n\n\n\nThe values which make a compound proposition true is called the \nsolution to the satisfiability problem\n.\n\n\nPredicates and Quantifiers\n\n\nPredicates\n\n\nStatements that involve variables such as $x + 3 = y$ and $x > 1$ are undecided when their variables are not given a value. We need a more powerfull logic, \npredicate logic\n, to model these statements.\n\n\nWe turn the statement $x > 1$ into the predicate $P(x)$ where $P$ is $x > 1$. When we give $x$ a value, the statement becomes a proposition, e.g. $P(4)$ becomes $4 > 1$ which is $\\top$.\n\n\nA predicate can have any number of variables, $P(x_1, x_2, ..., x_n)$. A predicate with $n$ variables is called an $n$-ary predicate.\n\n\nQuantifiers\n\n\nAssigning variables is not the only way to form a proposition from a predicate. \nQuantification\n expresses the extend to which a predicate is true over a range.\n\n\n\n\n\n\n\n\nName\n\n\nExample\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUniversal quantifier\n\n\n$\\forall x P(x)$\n\n\nis true if $P(x)$ is true for all x (domain)\n\n\n\n\n\n\nExistential quantifier\n\n\n$\\exists x P(X)$\n\n\nis true if $P(x)$ is true for at least one value in the domain\n\n\n\n\n\n\n\n\n\n\nIs $\\forall x (x^2 > x)$ where the domain is all real numbers true.\n\n\nNo, if $x = \\frac{1}{2}$, $x^2 > x$) is false, thus not all elements in the domain make $x^2 > x$ true.\n\n\n\n\nRestricting the domain\n\n\nConsider $\\forall x (x^2 > 0)$ where the domain of $x$ is $x < 0$. We could express that as:\n\n\n\n\n\n\\forall x \\;(x < 0 \\rightarrow x^2 > 0)\n\n\n\n\n\nTheir is a shorter notation for restricting the domain\n\n\n\n\n\n\\forall x < 0 \\;(x^2 > 0)\n\n\n\n\n\nPrecedence of Quantifiers\n\n\n$\\forall$ and $\\exists$ have a higher precedence that all other logical operators.\n\n\nBinding Variables\n\n\nWhen a quantifier is used on variable, or the variable is assigned a value, the variable is said to be \nbound\n. Predicates must have all the variables bound to be turned into a proposition. Variables that are not bound are \nfree\n.\n\n\nThe \nscope\n of a quantifier is the part of the logical expression to which it is applied, hence variables outside of the scope of all quantifiers are free (if their value has not been assigned).\n\n\nLogical Equivalence\n\n\nTwo expressions involving predicates and quantifiers are equal if their truth values are the same throughout the domain.\n\n\n\n\nShow that $\\forall x (P(x) \\land Q(x))$ and $\\forall x P(x) \\land \\forall x Q(x)$ are logically equivalent.\n\n\n\n\nLet $a$ be some element in the domain, thus $P(a) \\land Q(a)$ must be $\\top$.\n\n\nIf $P(a) \\land Q(a)$ is $\\top$, $P(a)$ and $Q(a)$ must both be $\\top$.\n\n\nSince $P(a)$ and $Q(a)$ are $\\top$ for all element in the domain, $\\forall x P(x) \\land \\forall x Q(x)$ must also be $\\top$.\n\n\n\n\nSo\n\n\n\\forall x \\; (P(x) \\land Q(x)) \\equiv \\forall x \\; P(x) \\land \\forall x \\; Q(x)\n\n\n\n\n\n\n\nNegation\n\n\n\n\n\n\n\n\nStatement\n\n\nEquivalent\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n$\u00ac\\forall x \\; P(x)$\n\n\n$\\exists x \\; \u00acP(x)$\n\n\nTheir is an $x$ for which $P(x)$ is $\\bot$\n\n\n\n\n\n\n$\u00ac\\exists x \\; P(x)$\n\n\n$\\forall x \\; \u00acP(x)$\n\n\nFor every $x$, $\u00acP(x)$ is $\\top$\n\n\n\n\n\n\n\n\n\n\nProve $\u00ac\\forall x \\; P(x) \\equiv \\exists x \\; \u00acP(x)$\n\n\n\n\n$\u00ac\\forall x \\; P(x)$ is $\\top$, if and only if $\\forall x \\; P(x)$ is $\\bot$\n\n\nIf $\\forall x \\; P(x)$ is $\\bot$, then their is atleast one element in the domain for which $\u00acP(x)$ is true.\n\n\nIt follows then the $\\exists x \\; \u00acP(x)$\n\n\n\n\n\n\nNested Quantifiers\n\n\nMore complex statements often involve more than one quantifier. For example the logical statement that \nif $x$ is positive and $y$ is negative, $xy$ is negative\n can be expressed as:\n\n\n\n\n\n\\forall x \\forall y \\; ((x > 0) \\land (y < 0) \\rightarrow (xy < 0))\n\n\n\n\n\nProof\n\n\nRules of Inference\n\n\nProofs are mathmatical arguments that determine the truth of a statement. \nBy an argument\n, means a sequence of statements that end in a conclusion. \nBy valid\n, means the conclusion must follow from the arguments. \nBy premise\n, means the argument is valid if and only if it is impossible for all premises to be true and the conclusion false.\n\n\nAn \nargument\n is propositional logic is a sequence of propositons, where the final proposition is the conclusion and all others are the premises. An \nargument form\n in propositional logic is a sequence of compound propositions that is \nvalid\n no matter what propositions are substitude for a premise, so long as the premises are true.\n\n\nThe \nmodus ponens\n (law of detachment) is one rule we can use to proof statements. \n\n\n(p \\land (p \\rightarrow q)) \\rightarrow q\n\n\n\n\n\n\n\nLet $p$ be \"it snows\" and $q$ be \"will go skiing\", if \"we will go skiing if it snows\" is \"we will go skiing\" true?\n\n\n\n\n\n\\begin{align}\n& p \\rightarrow q \\\\\n& p \\\\ \\hline\n\\therefore \\; & q\n\\end{align}\n\n\n\n\n\n\n\n\n\n\n\n\n\nRule of Inference\n\n\nTautology\n\n\nName\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{align} & p \\rightarrow q \\\\ & p \\\\ \\hline \\therefore \\; & q \\end{align}\n\n\n\n\n$(p \\land (p \\rightarrow q)) \\rightarrow q$\n\n\nModus ponens\n\n\n\n\n\n\n\n\n\\begin{align} & p \\rightarrow q \\\\ & \u00acq \\\\ \\hline \\therefore \\; & \u00acp \\end{align}\n\n\n\n\n$ (\u00acq \\land (p \\rightarrow q)) \\rightarrow \u00acp $\n\n\nModus tollens\n\n\n\n\n\n\n\n\n\\begin{align} & p \\rightarrow q \\\\ & q \\rightarrow r \\\\ \\hline \\therefore \\; & p \\rightarrow r \\end{align}\n\n\n\n\n$ ((p \\rightarrow q) \\land (q \\rightarrow r)) \\rightarrow (p \\rightarrow r) $\n\n\nHypothetical syllogism\n\n\n\n\n\n\n\n\n\\begin{align} & p \\lor q \\\\ & \u00acp \\\\ \\hline \\therefore \\; & q \\end{align}\n\n\n\n\n$ ((p \\lor q) \\land \u00acp) \\rightarrow q $\n\n\nDisjunctive syllogism\n\n\n\n\n\n\n\n\n\\begin{align} & p \\\\ \\hline \\therefore \\; & p \\lor q \\end{align}\n\n\n\n\n$ p \\rightarrow (p \\lor q) $\n\n\nAddition\n\n\n\n\n\n\n\n\n\\begin{align} & p \\land q \\\\ \\hline \\therefore \\; & p \\end{align}\n\n\n\n\n$ (p \\land q) \\rightarrow p $\n\n\nSimplification\n\n\n\n\n\n\n\n\n\\begin{align} & p \\\\ & q \\\\ \\hline \\therefore \\; & p \\land q \\end{align}\n\n\n\n\n$ ((p) \\land (q)) \\rightarrow (p \\land q) $\n\n\nConjunction\n\n\n\n\n\n\n\n\n\\begin{align} & p \\lor q \\\\ & \u00acp \\lor r \\\\ \\hline \\therefore \\; & q \\lor r \\end{align}\n\n\n\n\n$ ((p \\lor q) \\land (\u00acp \\lor r)) \\rightarrow (q \\lor r) $\n\n\nResolution\n\n\n\n\n\n\n\n\nUsing Rules of Inference to Build Arguments\n\n\n\n\nGiven the premesis: $\u00acp \\land q$, $r \\rightarrow p$, $\u00acr \\rightarrow s$, $s \\rightarrow t$ find an argument that shows the premisies lead to the conclusion $t$.\n\n\n\n\n\n\\begin{align}\n1)\\quad & \u00acp \\land q & \\text{premise} \\\\\n2)\\quad & \u00acp & \\text{simplification (1)} \\\\\n3)\\quad & r \\rightarrow p & \\text{premise} \\\\\n4)\\quad & \u00acr & \\text{modus tollens (2)(3)} \\\\\n5)\\quad & \u00acr \\rightarrow s & \\text{premise} \\\\\n6)\\quad & s & \\text{modus ponens (4)(5)} \\\\\n7)\\quad & s \\rightarrow t & \\text{premise} \\\\\n8)\\quad & t & \\text{modus ponens (6)(7)}\n\\end{align}\n\n\n\n\n\n\n\nFallacies\n\n\n$(p \\land (p \\rightarrow q)) \\rightarrow q$ is a tautology, fallacies often look like tautologys but are just contingencies:\n\n\n\n\nFallacy of affirming the conclusion\n\n\noccors when $(q \\land (p \\rightarrow q)) \\rightarrow p$ is treated as a tautology, but it is false when $p$ is false and $q$ is true.\n\n\nFallacy of denying the hypothesis\n\n\noccors when $(\u00acp \\land (p \\rightarrow q)) \\rightarrow \u00acq$ is treated as a tautology, but it is false when $p$ is false and $q$ is true.\n\n\n\n\nRules of Inference for Quantified Statements\n\n\n\n\n\n\n\n\nRule of Inference\n\n\nName\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n\n\n\\begin{align} & \\forall x P(x) \\\\ \\hline \\therefore \\; & P(c) \\end{align}\n\n\n\n\nUniversal instantiation\n\n\n$P(c)$ is true, where $c$ is an element of the domain, since all elements are true.\n\n\n\n\n\n\n\n\n\\begin{align} & P(c) \\\\ \\hline \\therefore \\; & \\forall x P(x) \\end{align}\n\n\n\n\nUniversal generalization\n\n\n$\\forall x P(x)$ is true, if $P(c)$ (where $c$ is an arbitary element in the domain) is true. Since we do not make any assumptions about $c$, other than its an element of the domain, all values of the domain must be true.\n\n\n\n\n\n\n\n\n\\begin{align} & \\exists x P(x) \\\\ \\hline \\therefore \\; & P(c) \\end{align}\n\n\n\n\nExistential instantiation\n\n\nTheir is an element $c$ in the domain that makes $P$ true. Note $c$ is not arbitary since some elements in the domain do not make $P$ true.\n\n\n\n\n\n\n\n\n\\begin{align} & P(c) \\\\ \\hline \\therefore \\; & \\exists x P(x) \\end{align}\n\n\n\n\nExistential generalization\n\n\nIf we know one element $c$ in the domain that makes $P$ true, then it follows that $\\exists x P(x)$\n\n\n\n\n\n\n\n\n\n\nShow that the premesis \"A student in the class has not read the book\" and \"Everyone in the class passed the exam\" implys the conclusion that \"Someone who passed the exam had not read the book\"\n\n\n\n\nLet $C(x)$ be \"$x$ is in the class\"\n\n\nLet $P(x)$ be \"$x$ passed the exam\"\n\n\nLet $B(x)$ be \"$x$ has read the book\"\n\n\n\n\n\n\n\n\\begin{align}\n(1)\\quad & \\exists x (C(x) \\land \u00acB(x)) && \\text{Premise} \\\\\n(2)\\quad & C(a) \\land \u00acB(a) && \\text{Existential instantiation (1)} \\\\\n(3)\\quad & C(a) && \\text{Simplification (2)} \\\\\n(4)\\quad & \\forall x (C(x) \\rightarrow P(x)) && \\text{Premise} \\\\\n(5)\\quad & C(a) \\rightarrow P(a) && \\text{Universal instantiation (4)} \\\\\n(6)\\quad & P(a) && \\text{Modus ponens (3, 5)} \\\\\n(7)\\quad & \u00acB(a) && \\text{Simplification (2)} \\\\\n(8)\\quad & P(a) \\land \u00acB(a) && \\text{Conjunction (6, 7)} \\\\\n(9)\\quad & \\exists x (P(x) \\land \u00acB(x)) && \\text{Existential generalization (8)}\n\\end{align}\n\n\n\n\n\n\n\nSet\n\n\nAn unordered collection of elements\n\n\nSet Operations\n\n\n\n\n\n\n\n\nName\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nEquality\n\n\n${1, 2, 3} = {3, 1, 2}$\n\n\n\n\n\n\nMembership\n\n\n$3 \\in {1, 2, 3}$\n\n\n\n\n\n\nNon-Membership\n\n\n$5 \\notin {1, 2, 3}$\n\n\n\n\n\n\nEmpty Set\n\n\n$\\emptyset = {}$\n\n\n\n\n\n\nUnion\n\n\n$A \\cup B$\n\n\n\n\n\n\nIntersection\n\n\n$A \\cap B$\n\n\n\n\n\n\nDiffrence\n\n\n$A - B$\n\n\n\n\n\n\nComplement\n\n\n$\\bar{A}$\n\n\n\n\n\n\nSubset\n\n\n$A \\subseteq B$\n\n\n\n\n\n\nSuperset\n\n\n$A \\supseteq B$\n\n\n\n\n\n\nPower Set\n\n\n$P(A)$ (set of all subsets)\n\n\n\n\n\n\nCardinality\n\n\n$\\vert A \\vert$\n\n\n\n\n\n\nCartesian Product\n\n\n$A \\times B$\n\n\n\n\n\n\n\n\nCommon Sets\n\n\n\n\n\n\n\n\nName\n\n\nSymbol\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBooleans\n\n\n$\\mathbb{B}$\n\n\n${true, false}$\n\n\n\n\n\n\nNatural numbers\n\n\n$\\mathbb{N}$\n\n\n${0, 1, 2, ...}$\n\n\n\n\n\n\nInteger\n\n\n$\\mathbb{Z}$\n\n\n${..., -2, -1, 0, 1, 2, ...}$\n\n\n\n\n\n\nPositive Integers\n\n\n$\\mathbb{Z}^+$\n\n\n$\\{z \\in Z \\mid z > 0\\}$\n\n\n\n\n\n\nReal Numbers\n\n\n$\\mathbb{R}$\n\n\n\n\n\n\n\n\nRational\n\n\n$\\mathbb{Q}$\n\n\n$\\{\\frac{a}{b} \\mid a \\in \\mathbb{Z}, b \\in \\mathbb{Z}^+\\}$\n\n\n\n\n\n\nComplex Numbers\n\n\n$\\mathbb{C}$\n\n\n\n\n\n\n\n\n\n\nSet Identitys\n\n\n\n\n$A \\cup A = A$\n\n\n$A \\cap A = A$\n\n\n$\\bar{\\bar{A}} = A$\n\n\n$A \\cup B = B \\cup A$\n\n\n$A \\cap B = B \\cap A$\n\n\n$A \\cup (B \\cap C) = (A \\cap B) \\cup (A \\cap C)$\n\n\n$\\bar{A \\cap B} = \\bar{A} \\cup \\bar{B}$\n\n\n$\\bar{A \\cup B} = \\bar{A} \\cap \\bar{B}$\n\n\n$A \\cup (A \\cap B) = A$\n\n\n$A \\cap (A \\cup B) = A$\n\n\n\n\nFunctions\n\n\nSyntax\n\n\nA function $f$ from set $A$ to set $B$ assigns an element from $A$ to $B$, this is written as $f: A \\rightarrow B$.\n\n\nExamples:\n\n\n\n\nCeil - $\\lceil \\cdot \\rceil : \\mathbb{R} \\rightarrow \\mathbb{Z}$\n\n\nFloor - $\\lfloor \\cdot \\rfloor : \\mathbb{R} \\rightarrow \\mathbb{Z}$\n\n\nIdentity - $\\iota_A : A \\rightarrow A$\n\n\nFactorial - $! : \\mathbb{N} \\rightarrow \\mathbb{N}$\n\n\n\n\nInjective\n\n\n$f : A \\rightarrow B$ iff $\\forall a, c \\in A (\\text{if } f(a) = f(c) \\text{ then } a = c)$\n\n\nFor every element in A their is an element in B which maps to it.\n\n\nExamples:\n\n\n\n\nIdentity function\n\n\n$\\sqrt{\\cdot}$\n\n\n\n\nSurjective\n\n\n$f: A \\rightarrow B$ is surjective iff $\\forall b \\in B \\; \\exists a \\in A (f(a) = b)$\n\n\nFor every element in B, their is an element in A which is mapped onto it.\n\n\nExamples:\n\n\n\n\nIdentity function\n\n\n$\\mathbb{Z} \\mod m$ for $m > 1$\n\n\n\n\nOne-to-one correspondence or bijection\n\n\n$f: A \\rightarrow B$ is a bijection iff it is both injective and bijective\n\n\nEvery element in the domain is mapped to a value in the range and visa-versa.\n\n\nExamples\n\n\n\n\nIdentity function\n\n\n$\\sqrt{x} : \\mathbb{R}^+ \\rightarrow \\mathbb{R}^+$\n\n\n\n\nComposition\n\n\nLet $f : B \\rightarrow C$ and $g: A \\rightarrow B$. The composition function $f \\circ g : A \\rightarrow C$ is $(f \\circ g)(a) = f(g(a))$\n\n\n\n\nThe composition of two functions is a function\n\n\nThe composition of two injective functions is a injective function\n\n\nThe composition of two surjective functions is a surjective function\n\n\nThe composition of two bijections is a bijection\n\n\n\n\nInverse\n\n\nIf $f: A \\rightarrow B$ is a bijection, then the inverse of $f$, written $f^{-1}:B\\rightarrow A$ is $f^{-1}(b) = a$ iff $f(a) = b$\n\n\n\n\nInverse of the identity function, is the identity function\n\n\nInverse of $\\sqrt{x} : \\mathbb{R}^+ \\rightarrow \\mathbb{R}^+$ is $x^2 : \\mathbb{R}^+ \\rightarrow \\mathbb{R}^+$ \n\n\n$f^{-1} \\circ f$ and $f \\circ f^{-1}$ is the identity function\n\n\n\n\nRelations\n\n\nA binary relation $R$ on sets $A$ and $B$ is a subset $R \\subseteq A \\times B$\n\n\n\n\nOften written as $R\\;b$ for $(a, b) \\in R$\n\n\nA function $f$ is a restricted relation where \n\n\\forall a \\in A \\exists b \\in B \\; (((a, b) \\in f) \\land \\forall c \\in B \\; ((a, c) \\in f \\rightarrow c = b))\n\n\n\n\n\nFor all a in $A$ their exsists a $b$ in $B$\n\n\nwhere (a, b) in relation $f$\n\n\nand $b$ is unique  \n\n\n\n\n\n\nGiven sets $A_1, ..., A_n$ a subset $R \\subseteq A_1 \\times ... \\times A_n$ is an $n$-ary relation.\n\n\n\n\n$R \\subseteq A \\times B$ where $A$ is students and $B$ is courses, $(\\text{Ben}, \\text{DMMR}) \\in R$\n\n\nOperations\n\n\nRelations are sets, so we can use the same operations, i.e. $R \\cup S$ or $R \\cap S$\n\n\nRealtion composition\n\n\nLet $R \\subseteq B \\times C$ and $S \\subseteq A \\times B$. The composition relation $(R \\circ S) \\subseteq A \\times C$ is ${(a, c) \\;|\\; \\exists b (a, b) \\in S \\land (b, c) \\in R}$\n\n\nThe expression specifys the relations where $R$ and $S$ have a common $B$, thus $R \\circ S \\subseteq A \\times C$\n\n\nClosure $R$ is a relation on $A$:\n\n\n\n\n$R^0$ is the identity relation $\\iota_A$\n\n\n$R^{n+1} = R^n \\circ R$\n\n\n$R^* = \\bigcup_{n \\geq 0}R^n$\n\n\n\n\nGraph reachability\n\n\nProperties\n\n\n\n\nReflexive iff $\\forall x \\in A (x, x) \\in R$.\n\n\n$\\leq$, $=$ and $|$ are reflexive, but $<$ is not.\n\n\nSymetic iff $\\forall x, y \\in A ((x, y) \\in R \\rightarrow (y, x) \\in R)$.\n\n\n$=$ is symmetic, but $\\leq$, $<$ and $|$ are not.\n\n\nantisymetic iff $\\forall x, y \\in A (((x, y) \\in R \\land (y, x) \\in R) \\rightarrow x = y)$.\n\n\n$\\leq$, $=$, $<$ are antisymmetic but $|$ is not.\n\n\ntransitive iff $\\forall x, y, z \\in A (((x, y) \\in R \\land (y, z) \\in R \\rightarrow (x, z) \\in R)$.\n\n\n$\\leq$, $=$, $<$ and $|$ are transitive.\n\n\n\n\nA relation $R$ is an equivalance realtion iff it is reflexive, symetric and transitive.\n\n\nEquivalnce classes\n\n\nLet $R$ be an equivalence realtion on a set $A$ and $a \\in A$ let $[a]_R = {s \\;|\\; (a, s) \\in R}$ be the equivalence class of a w.r.t $R$.\n\n\nIf $b \\in [a]_R$ the $b$ is called a representative of the equivalance class.\n\n\nLet $R$ be an equivalnce realtion on $A$ amd $a, b \\in A$. Then following statements are equivalnet\n\n\n\n\n$a R b$\n\n\n$[a]_R = [b]_R$\n\n\n$[a]_R \\cap [b]_R \\ne \\emptyset$",
            "title": "Discrete Mathmatics and Mathmatical Reasoning"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#propositonal-logic",
            "text": "",
            "title": "Propositonal Logic"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#propositions",
            "text": "Proposition  A declarative sentence (declares a fact) that is either true or false.      Propositon  Not propositions      It is raining.  What is the data?    $\\pi = 1.23$  $1 + x = 2$",
            "title": "Propositions"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-operators",
            "text": "From these propositions we can from new compound propositions with logical operators:     Operation  Example  Explanation      Negation  $\\neg p$  it is not the case that $p$    Conjunction  $p \\land q$  both $p$ and $q$ must be true for $p \\land q$ to be true    Disjunction  $p \\lor q$  False when both $p$ and $q$ are false, true otherwise    Exclusive Or  $p \\oplus q$  Either $p$ or $q$ must be true ( not both ) for $p \\oplus q$ to be true    Implication  $p \\rightarrow q$  False when $p$ is true and $q$ is false, true otherwise. $p$ is the hypothesis/antecedent and $q$ is the conclusion/conseqence    Biconditional  $p \\leftrightarrow q$  $p$ if and only if $q$, true when both $p$ and $q$ have the same truth values",
            "title": "Logical operators"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#truth-tables",
            "text": "With these logical operators we can build complex logical statements such as: $(p \\lor q) \\rightarrow (p \\land q)$. To construct truth tables for these expressions we start with the individual variables $p$ and $q$, and solve sub expressions until we reach the full expression.   \n\\begin{array}{c|c|c|c|c|c}\np & q & \\neg q & p \\lor \\neg q & p \\land \\neg q & (p \\lor q) \\rightarrow (p \\land q) \\\\ \\hline\n\\top & \\top & \\bot & \\top & \\top & \\top \\\\\n\\top & \\bot & \\top & \\top & \\bot & \\bot \\\\\n\\bot & \\top & \\bot & \\bot & \\bot & \\top \\\\\n\\bot & \\bot & \\top & \\top & \\bot & \\bot \\\\\n\\end{array}",
            "title": "Truth tables"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#operator-precedence",
            "text": "The order of which operators apply are as follows:     Operator  Precedence      $\\neg$  1    $\\land$  2    $\\lor$  3    $\\rightarrow$  4    $\\leftrightarrow$  5",
            "title": "Operator precedence"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-equivalences",
            "text": "Tautology  A compound proposition that is  true , no matter what values the propositional variables hold.  Contradiction  A compound proposition that is  false , no matter what values the propositional variables hold.  Contingency  Compound propositions that are neither a tautology or a contradiction.    $p \\lor \\neg p$ is a tautology  $p \\land \\neg p$ is a contradiction  $p \\lor q$ is a contingency   Two compound propositions are  logically equivilent  if they have the same truth values in all cases. This occors when $p \\leftrightarrow q$ is a tautology, where $p$ and $q$ are compound propositions. $p \\equiv q$ is a statement, denoting that $p$ and $q$ are logically equivilent.",
            "title": "Logical Equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#important-equivalences",
            "text": "Equivalence  Name      $p \\land \\top  \\equiv p \\\\ p \\lor \\bot \\equiv p $  Identity laws    $p \\lor \\top  \\equiv \\top \\\\ p \\land \\bot \\equiv \\bot $  Domination laws    $p \\lor p \\equiv p \\\\ p \\land p \\equiv p$  Idempotent laws    $\u00ac\u00acp \\equiv p$  Double negation law    $p \\lor q \\equiv q \\lor p \\\\ p \\land q \\equiv q \\land p$  Commutative laws    $(p \\lor q) \\lor r \\equiv p \\lor (q \\lor r) \\lor p \\\\ (p \\land q) \\land r \\equiv p \\land (q \\land r) \\land p$  Associative laws    $p \\lor (q \\land r) \\equiv (p \\lor q) \\land (p \\lor r) \\\\ p \\land (q \\lor r) \\equiv (p \\land q) \\lor (p \\land r)$  Distributive laws    $\u00ac(p \\land q) \\equiv \u00acp \\lor \u00acq \\\\ \u00ac(p \\lor q) \\equiv \u00acp \\land \u00acq$  De Morgan's laws    $p \\lor (p \\land q) \\equiv p \\\\ p \\land (p \\lor q) \\equiv p$  Absorption laws    $p \\lor \u00acp \\equiv \\top \\\\ p \\land \u00acp \\equiv \\bot$  Negation laws    $ p \\rightarrow q \\equiv \u00acp \\lor q \\\\ p \\rightarrow q \\equiv \u00acq \\rightarrow \u00acp \\\\ p \\lor q \\equiv \u00acp \\rightarrow q \\\\ p \\land q \\equiv \u00ac(p \\rightarrow \u00acq) \\\\ \u00ac(p \\rightarrow q) \\equiv p \\land \u00acq \\\\ (p \\rightarrow q) \\land (p \\rightarrow r) \\equiv p \\rightarrow (q \\land r) \\\\ (p \\rightarrow q) \\lor (p \\rightarrow r) \\equiv p \\rightarrow (q \\lor r) \\\\ (p \\rightarrow r) \\land (q \\rightarrow r) \\equiv (p \\lor q) \\rightarrow r \\\\ (p \\rightarrow r) \\lor (q \\rightarrow r) \\equiv (p \\land q) \\rightarrow r $  Logical equivalences involving conditional statements    $ p \\leftrightarrow q \\equiv (p \\rightarrow q) \\land (q \\rightarrow p) \\\\ p \\leftrightarrow q \\equiv \u00acp \\leftrightarrow \u00acq\\\\ p \\leftrightarrow q \\equiv (p \\land q) \\lor (\u00acp \\land \u00acq)\\\\ \u00ac(p \\leftrightarrow q) \\equiv p \\leftrightarrow \u00acq $  Logical equivalences involving biconditionals",
            "title": "Important Equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#notation",
            "text": "Simular to $\\sum$, their exsists a notation for $\\lor$ and $\\land$. \np_0 \\lor p_1 \\lor ... \\lor p_n \\equiv \\bigvee^n_{i = 0}p_i  \np_0 \\land p_1 \\land ... \\land p_n \\equiv \\bigwedge^n_{i = 0}p_i",
            "title": "Notation"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#constructing-new-logical-equivalences",
            "text": "Using equivalences we already know, we can prove expressions are tautologys or that two expressions are logically equivelent. While a truth table could also be used, it is much shorted to apply laws.   Show that $(p \\land q) \\rightarrow (p \\lor q)$ is a tautology. \n\\begin{align}\n(p \\land q) \\rightarrow (p \\lor q) &\\equiv \u00ac(p \\land q) \\lor (p \\lor q) & \\\\\n                               &\\equiv (\u00acp \\lor \u00acq) \\lor (p \\lor q) &\\text{De Morgan's Law} \\\\\n                               &\\equiv (\u00acp \\lor p) \\lor (\u00acq \\lor q) &\\text{Assosiative and Commutative Law} \\\\\n                               &\\equiv \\top \\lor \\top &\\text{Negation Law} \\\\\n                               &\\equiv \\top &\\text{Domination Law}\n\\end{align}",
            "title": "Constructing new logical equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#satisfaction",
            "text": "Satisfiable  A compound proposition were there  is a  assignment of truth values that make it true.  Unsatisfiable  A compound proposition were there  is no  assignment of truth values that make it true.   The values which make a compound proposition true is called the  solution to the satisfiability problem .",
            "title": "Satisfaction"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#predicates-and-quantifiers",
            "text": "",
            "title": "Predicates and Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#predicates",
            "text": "Statements that involve variables such as $x + 3 = y$ and $x > 1$ are undecided when their variables are not given a value. We need a more powerfull logic,  predicate logic , to model these statements.  We turn the statement $x > 1$ into the predicate $P(x)$ where $P$ is $x > 1$. When we give $x$ a value, the statement becomes a proposition, e.g. $P(4)$ becomes $4 > 1$ which is $\\top$.  A predicate can have any number of variables, $P(x_1, x_2, ..., x_n)$. A predicate with $n$ variables is called an $n$-ary predicate.",
            "title": "Predicates"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#quantifiers",
            "text": "Assigning variables is not the only way to form a proposition from a predicate.  Quantification  expresses the extend to which a predicate is true over a range.     Name  Example  Note      Universal quantifier  $\\forall x P(x)$  is true if $P(x)$ is true for all x (domain)    Existential quantifier  $\\exists x P(X)$  is true if $P(x)$ is true for at least one value in the domain      Is $\\forall x (x^2 > x)$ where the domain is all real numbers true.  No, if $x = \\frac{1}{2}$, $x^2 > x$) is false, thus not all elements in the domain make $x^2 > x$ true.",
            "title": "Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#restricting-the-domain",
            "text": "Consider $\\forall x (x^2 > 0)$ where the domain of $x$ is $x < 0$. We could express that as:   \n\\forall x \\;(x < 0 \\rightarrow x^2 > 0)   Their is a shorter notation for restricting the domain   \n\\forall x < 0 \\;(x^2 > 0)",
            "title": "Restricting the domain"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#precedence-of-quantifiers",
            "text": "$\\forall$ and $\\exists$ have a higher precedence that all other logical operators.",
            "title": "Precedence of Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#binding-variables",
            "text": "When a quantifier is used on variable, or the variable is assigned a value, the variable is said to be  bound . Predicates must have all the variables bound to be turned into a proposition. Variables that are not bound are  free .  The  scope  of a quantifier is the part of the logical expression to which it is applied, hence variables outside of the scope of all quantifiers are free (if their value has not been assigned).",
            "title": "Binding Variables"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-equivalence",
            "text": "Two expressions involving predicates and quantifiers are equal if their truth values are the same throughout the domain.   Show that $\\forall x (P(x) \\land Q(x))$ and $\\forall x P(x) \\land \\forall x Q(x)$ are logically equivalent.   Let $a$ be some element in the domain, thus $P(a) \\land Q(a)$ must be $\\top$.  If $P(a) \\land Q(a)$ is $\\top$, $P(a)$ and $Q(a)$ must both be $\\top$.  Since $P(a)$ and $Q(a)$ are $\\top$ for all element in the domain, $\\forall x P(x) \\land \\forall x Q(x)$ must also be $\\top$.   So \n\\forall x \\; (P(x) \\land Q(x)) \\equiv \\forall x \\; P(x) \\land \\forall x \\; Q(x)",
            "title": "Logical Equivalence"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#negation",
            "text": "Statement  Equivalent  Note      $\u00ac\\forall x \\; P(x)$  $\\exists x \\; \u00acP(x)$  Their is an $x$ for which $P(x)$ is $\\bot$    $\u00ac\\exists x \\; P(x)$  $\\forall x \\; \u00acP(x)$  For every $x$, $\u00acP(x)$ is $\\top$      Prove $\u00ac\\forall x \\; P(x) \\equiv \\exists x \\; \u00acP(x)$   $\u00ac\\forall x \\; P(x)$ is $\\top$, if and only if $\\forall x \\; P(x)$ is $\\bot$  If $\\forall x \\; P(x)$ is $\\bot$, then their is atleast one element in the domain for which $\u00acP(x)$ is true.  It follows then the $\\exists x \\; \u00acP(x)$",
            "title": "Negation"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#nested-quantifiers",
            "text": "More complex statements often involve more than one quantifier. For example the logical statement that  if $x$ is positive and $y$ is negative, $xy$ is negative  can be expressed as:   \n\\forall x \\forall y \\; ((x > 0) \\land (y < 0) \\rightarrow (xy < 0))",
            "title": "Nested Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#proof",
            "text": "",
            "title": "Proof"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#rules-of-inference",
            "text": "Proofs are mathmatical arguments that determine the truth of a statement.  By an argument , means a sequence of statements that end in a conclusion.  By valid , means the conclusion must follow from the arguments.  By premise , means the argument is valid if and only if it is impossible for all premises to be true and the conclusion false.  An  argument  is propositional logic is a sequence of propositons, where the final proposition is the conclusion and all others are the premises. An  argument form  in propositional logic is a sequence of compound propositions that is  valid  no matter what propositions are substitude for a premise, so long as the premises are true.  The  modus ponens  (law of detachment) is one rule we can use to proof statements.  \n(p \\land (p \\rightarrow q)) \\rightarrow q    Let $p$ be \"it snows\" and $q$ be \"will go skiing\", if \"we will go skiing if it snows\" is \"we will go skiing\" true?   \n\\begin{align}\n& p \\rightarrow q \\\\\n& p \\\\ \\hline\n\\therefore \\; & q\n\\end{align}       Rule of Inference  Tautology  Name       \\begin{align} & p \\rightarrow q \\\\ & p \\\\ \\hline \\therefore \\; & q \\end{align}   $(p \\land (p \\rightarrow q)) \\rightarrow q$  Modus ponens     \\begin{align} & p \\rightarrow q \\\\ & \u00acq \\\\ \\hline \\therefore \\; & \u00acp \\end{align}   $ (\u00acq \\land (p \\rightarrow q)) \\rightarrow \u00acp $  Modus tollens     \\begin{align} & p \\rightarrow q \\\\ & q \\rightarrow r \\\\ \\hline \\therefore \\; & p \\rightarrow r \\end{align}   $ ((p \\rightarrow q) \\land (q \\rightarrow r)) \\rightarrow (p \\rightarrow r) $  Hypothetical syllogism     \\begin{align} & p \\lor q \\\\ & \u00acp \\\\ \\hline \\therefore \\; & q \\end{align}   $ ((p \\lor q) \\land \u00acp) \\rightarrow q $  Disjunctive syllogism     \\begin{align} & p \\\\ \\hline \\therefore \\; & p \\lor q \\end{align}   $ p \\rightarrow (p \\lor q) $  Addition     \\begin{align} & p \\land q \\\\ \\hline \\therefore \\; & p \\end{align}   $ (p \\land q) \\rightarrow p $  Simplification     \\begin{align} & p \\\\ & q \\\\ \\hline \\therefore \\; & p \\land q \\end{align}   $ ((p) \\land (q)) \\rightarrow (p \\land q) $  Conjunction     \\begin{align} & p \\lor q \\\\ & \u00acp \\lor r \\\\ \\hline \\therefore \\; & q \\lor r \\end{align}   $ ((p \\lor q) \\land (\u00acp \\lor r)) \\rightarrow (q \\lor r) $  Resolution",
            "title": "Rules of Inference"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#using-rules-of-inference-to-build-arguments",
            "text": "Given the premesis: $\u00acp \\land q$, $r \\rightarrow p$, $\u00acr \\rightarrow s$, $s \\rightarrow t$ find an argument that shows the premisies lead to the conclusion $t$.   \n\\begin{align}\n1)\\quad & \u00acp \\land q & \\text{premise} \\\\\n2)\\quad & \u00acp & \\text{simplification (1)} \\\\\n3)\\quad & r \\rightarrow p & \\text{premise} \\\\\n4)\\quad & \u00acr & \\text{modus tollens (2)(3)} \\\\\n5)\\quad & \u00acr \\rightarrow s & \\text{premise} \\\\\n6)\\quad & s & \\text{modus ponens (4)(5)} \\\\\n7)\\quad & s \\rightarrow t & \\text{premise} \\\\\n8)\\quad & t & \\text{modus ponens (6)(7)}\n\\end{align}",
            "title": "Using Rules of Inference to Build Arguments"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#fallacies",
            "text": "$(p \\land (p \\rightarrow q)) \\rightarrow q$ is a tautology, fallacies often look like tautologys but are just contingencies:   Fallacy of affirming the conclusion  occors when $(q \\land (p \\rightarrow q)) \\rightarrow p$ is treated as a tautology, but it is false when $p$ is false and $q$ is true.  Fallacy of denying the hypothesis  occors when $(\u00acp \\land (p \\rightarrow q)) \\rightarrow \u00acq$ is treated as a tautology, but it is false when $p$ is false and $q$ is true.",
            "title": "Fallacies"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#rules-of-inference-for-quantified-statements",
            "text": "Rule of Inference  Name  Notes       \\begin{align} & \\forall x P(x) \\\\ \\hline \\therefore \\; & P(c) \\end{align}   Universal instantiation  $P(c)$ is true, where $c$ is an element of the domain, since all elements are true.     \\begin{align} & P(c) \\\\ \\hline \\therefore \\; & \\forall x P(x) \\end{align}   Universal generalization  $\\forall x P(x)$ is true, if $P(c)$ (where $c$ is an arbitary element in the domain) is true. Since we do not make any assumptions about $c$, other than its an element of the domain, all values of the domain must be true.     \\begin{align} & \\exists x P(x) \\\\ \\hline \\therefore \\; & P(c) \\end{align}   Existential instantiation  Their is an element $c$ in the domain that makes $P$ true. Note $c$ is not arbitary since some elements in the domain do not make $P$ true.     \\begin{align} & P(c) \\\\ \\hline \\therefore \\; & \\exists x P(x) \\end{align}   Existential generalization  If we know one element $c$ in the domain that makes $P$ true, then it follows that $\\exists x P(x)$      Show that the premesis \"A student in the class has not read the book\" and \"Everyone in the class passed the exam\" implys the conclusion that \"Someone who passed the exam had not read the book\"   Let $C(x)$ be \"$x$ is in the class\"  Let $P(x)$ be \"$x$ passed the exam\"  Let $B(x)$ be \"$x$ has read the book\"    \n\\begin{align}\n(1)\\quad & \\exists x (C(x) \\land \u00acB(x)) && \\text{Premise} \\\\\n(2)\\quad & C(a) \\land \u00acB(a) && \\text{Existential instantiation (1)} \\\\\n(3)\\quad & C(a) && \\text{Simplification (2)} \\\\\n(4)\\quad & \\forall x (C(x) \\rightarrow P(x)) && \\text{Premise} \\\\\n(5)\\quad & C(a) \\rightarrow P(a) && \\text{Universal instantiation (4)} \\\\\n(6)\\quad & P(a) && \\text{Modus ponens (3, 5)} \\\\\n(7)\\quad & \u00acB(a) && \\text{Simplification (2)} \\\\\n(8)\\quad & P(a) \\land \u00acB(a) && \\text{Conjunction (6, 7)} \\\\\n(9)\\quad & \\exists x (P(x) \\land \u00acB(x)) && \\text{Existential generalization (8)}\n\\end{align}",
            "title": "Rules of Inference for Quantified Statements"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set",
            "text": "An unordered collection of elements",
            "title": "Set"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set-operations",
            "text": "Name  Example      Equality  ${1, 2, 3} = {3, 1, 2}$    Membership  $3 \\in {1, 2, 3}$    Non-Membership  $5 \\notin {1, 2, 3}$    Empty Set  $\\emptyset = {}$    Union  $A \\cup B$    Intersection  $A \\cap B$    Diffrence  $A - B$    Complement  $\\bar{A}$    Subset  $A \\subseteq B$    Superset  $A \\supseteq B$    Power Set  $P(A)$ (set of all subsets)    Cardinality  $\\vert A \\vert$    Cartesian Product  $A \\times B$",
            "title": "Set Operations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#common-sets",
            "text": "Name  Symbol  Description      Booleans  $\\mathbb{B}$  ${true, false}$    Natural numbers  $\\mathbb{N}$  ${0, 1, 2, ...}$    Integer  $\\mathbb{Z}$  ${..., -2, -1, 0, 1, 2, ...}$    Positive Integers  $\\mathbb{Z}^+$  $\\{z \\in Z \\mid z > 0\\}$    Real Numbers  $\\mathbb{R}$     Rational  $\\mathbb{Q}$  $\\{\\frac{a}{b} \\mid a \\in \\mathbb{Z}, b \\in \\mathbb{Z}^+\\}$    Complex Numbers  $\\mathbb{C}$",
            "title": "Common Sets"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set-identitys",
            "text": "$A \\cup A = A$  $A \\cap A = A$  $\\bar{\\bar{A}} = A$  $A \\cup B = B \\cup A$  $A \\cap B = B \\cap A$  $A \\cup (B \\cap C) = (A \\cap B) \\cup (A \\cap C)$  $\\bar{A \\cap B} = \\bar{A} \\cup \\bar{B}$  $\\bar{A \\cup B} = \\bar{A} \\cap \\bar{B}$  $A \\cup (A \\cap B) = A$  $A \\cap (A \\cup B) = A$",
            "title": "Set Identitys"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#syntax",
            "text": "A function $f$ from set $A$ to set $B$ assigns an element from $A$ to $B$, this is written as $f: A \\rightarrow B$.  Examples:   Ceil - $\\lceil \\cdot \\rceil : \\mathbb{R} \\rightarrow \\mathbb{Z}$  Floor - $\\lfloor \\cdot \\rfloor : \\mathbb{R} \\rightarrow \\mathbb{Z}$  Identity - $\\iota_A : A \\rightarrow A$  Factorial - $! : \\mathbb{N} \\rightarrow \\mathbb{N}$",
            "title": "Syntax"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#injective",
            "text": "$f : A \\rightarrow B$ iff $\\forall a, c \\in A (\\text{if } f(a) = f(c) \\text{ then } a = c)$  For every element in A their is an element in B which maps to it.  Examples:   Identity function  $\\sqrt{\\cdot}$",
            "title": "Injective"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#surjective",
            "text": "$f: A \\rightarrow B$ is surjective iff $\\forall b \\in B \\; \\exists a \\in A (f(a) = b)$  For every element in B, their is an element in A which is mapped onto it.  Examples:   Identity function  $\\mathbb{Z} \\mod m$ for $m > 1$",
            "title": "Surjective"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#one-to-one-correspondence-or-bijection",
            "text": "$f: A \\rightarrow B$ is a bijection iff it is both injective and bijective  Every element in the domain is mapped to a value in the range and visa-versa.  Examples   Identity function  $\\sqrt{x} : \\mathbb{R}^+ \\rightarrow \\mathbb{R}^+$",
            "title": "One-to-one correspondence or bijection"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#composition",
            "text": "Let $f : B \\rightarrow C$ and $g: A \\rightarrow B$. The composition function $f \\circ g : A \\rightarrow C$ is $(f \\circ g)(a) = f(g(a))$   The composition of two functions is a function  The composition of two injective functions is a injective function  The composition of two surjective functions is a surjective function  The composition of two bijections is a bijection",
            "title": "Composition"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#inverse",
            "text": "If $f: A \\rightarrow B$ is a bijection, then the inverse of $f$, written $f^{-1}:B\\rightarrow A$ is $f^{-1}(b) = a$ iff $f(a) = b$   Inverse of the identity function, is the identity function  Inverse of $\\sqrt{x} : \\mathbb{R}^+ \\rightarrow \\mathbb{R}^+$ is $x^2 : \\mathbb{R}^+ \\rightarrow \\mathbb{R}^+$   $f^{-1} \\circ f$ and $f \\circ f^{-1}$ is the identity function",
            "title": "Inverse"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#relations",
            "text": "A binary relation $R$ on sets $A$ and $B$ is a subset $R \\subseteq A \\times B$   Often written as $R\\;b$ for $(a, b) \\in R$  A function $f$ is a restricted relation where  \n\\forall a \\in A \\exists b \\in B \\; (((a, b) \\in f) \\land \\forall c \\in B \\; ((a, c) \\in f \\rightarrow c = b))   For all a in $A$ their exsists a $b$ in $B$  where (a, b) in relation $f$  and $b$ is unique      Given sets $A_1, ..., A_n$ a subset $R \\subseteq A_1 \\times ... \\times A_n$ is an $n$-ary relation.   $R \\subseteq A \\times B$ where $A$ is students and $B$ is courses, $(\\text{Ben}, \\text{DMMR}) \\in R$",
            "title": "Relations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#operations",
            "text": "Relations are sets, so we can use the same operations, i.e. $R \\cup S$ or $R \\cap S$",
            "title": "Operations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#realtion-composition",
            "text": "Let $R \\subseteq B \\times C$ and $S \\subseteq A \\times B$. The composition relation $(R \\circ S) \\subseteq A \\times C$ is ${(a, c) \\;|\\; \\exists b (a, b) \\in S \\land (b, c) \\in R}$  The expression specifys the relations where $R$ and $S$ have a common $B$, thus $R \\circ S \\subseteq A \\times C$  Closure $R$ is a relation on $A$:   $R^0$ is the identity relation $\\iota_A$  $R^{n+1} = R^n \\circ R$  $R^* = \\bigcup_{n \\geq 0}R^n$",
            "title": "Realtion composition"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#graph-reachability",
            "text": "",
            "title": "Graph reachability"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#properties",
            "text": "Reflexive iff $\\forall x \\in A (x, x) \\in R$.  $\\leq$, $=$ and $|$ are reflexive, but $<$ is not.  Symetic iff $\\forall x, y \\in A ((x, y) \\in R \\rightarrow (y, x) \\in R)$.  $=$ is symmetic, but $\\leq$, $<$ and $|$ are not.  antisymetic iff $\\forall x, y \\in A (((x, y) \\in R \\land (y, x) \\in R) \\rightarrow x = y)$.  $\\leq$, $=$, $<$ are antisymmetic but $|$ is not.  transitive iff $\\forall x, y, z \\in A (((x, y) \\in R \\land (y, z) \\in R \\rightarrow (x, z) \\in R)$.  $\\leq$, $=$, $<$ and $|$ are transitive.   A relation $R$ is an equivalance realtion iff it is reflexive, symetric and transitive.",
            "title": "Properties"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#equivalnce-classes",
            "text": "Let $R$ be an equivalence realtion on a set $A$ and $a \\in A$ let $[a]_R = {s \\;|\\; (a, s) \\in R}$ be the equivalence class of a w.r.t $R$.  If $b \\in [a]_R$ the $b$ is called a representative of the equivalance class.  Let $R$ be an equivalnce realtion on $A$ amd $a, b \\in A$. Then following statements are equivalnet   $a R b$  $[a]_R = [b]_R$  $[a]_R \\cap [b]_R \\ne \\emptyset$",
            "title": "Equivalnce classes"
        },
        {
            "location": "/Introduction-to-Computer-Systems/",
            "text": "Floating point\n\n\n\n\nMantissa/significand\n\n\nFractional part\n\n\nExponent\n\n\nPower of $2$\n\n\n\n\n\n\nConvert $25_{10}$ in floating point form\n\n\n$25_{10} = 011001_2$\n\n\n$1.1001 \\times 2^4$\n\n\n\n\nWhy normalize?\n\n\n\n\nSimplifiys machine representation\n\n\nSimplifys comparisons e.g. $0.00000101$ vs $0.000001$\n\n\nMore compact for small/large numbers\n\n\n\n\nIEEE 654 Floating Point Standard\n\n\n\n\n1'st bit is sign bit ($s$)\n\n\n8 bits for exponent ($exp$)\n\n\nrest for mantissa ($m$)\n\n\n\n\nEncoding:\n$s \\times m \\times 2 ^ {exp - 127}$\n\n\n(127 is the \nbias\n)\n\n\n$0.75_{10} = 0.11_2 = {(1.1 \\times 2^{-1})}_2$\n\n\nWhy bias?\n\n\n\n\nExponent can always be positive (no need to store sign bit)\n\n\nSimplifys comparison operations\n\n\n\n\nSpecial values\n\n\n\n\n\n\n\n\nExponenent\n\n\nMantisa\n\n\nNumber\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n1-254\n\n\nAnything\n\n\nFloating point number\n\n\n\n\n\n\n255\n\n\n0\n\n\nInfinity (signed)\n\n\n\n\n\n\n255\n\n\nnon-zero\n\n\nNaN (not a number)",
            "title": "Introduction to Computer Systems"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#floating-point",
            "text": "Mantissa/significand  Fractional part  Exponent  Power of $2$    Convert $25_{10}$ in floating point form  $25_{10} = 011001_2$  $1.1001 \\times 2^4$",
            "title": "Floating point"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#why-normalize",
            "text": "Simplifiys machine representation  Simplifys comparisons e.g. $0.00000101$ vs $0.000001$  More compact for small/large numbers",
            "title": "Why normalize?"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#ieee-654-floating-point-standard",
            "text": "1'st bit is sign bit ($s$)  8 bits for exponent ($exp$)  rest for mantissa ($m$)   Encoding:\n$s \\times m \\times 2 ^ {exp - 127}$  (127 is the  bias )  $0.75_{10} = 0.11_2 = {(1.1 \\times 2^{-1})}_2$",
            "title": "IEEE 654 Floating Point Standard"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#why-bias",
            "text": "Exponent can always be positive (no need to store sign bit)  Simplifys comparison operations",
            "title": "Why bias?"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#special-values",
            "text": "Exponenent  Mantisa  Number      0  0  0    1-254  Anything  Floating point number    255  0  Infinity (signed)    255  non-zero  NaN (not a number)",
            "title": "Special values"
        },
        {
            "location": "/Introduction-to-Software-Engineering/",
            "text": "Use Cases\n\n\n\n\nUse case\n\n\nA task involving the system which has value for one or more stakeholders.\n\n\nActors\n\n\nA stakeholder who takes an active part in the use case.\n\n\nPrimary Actor\n\n\nStakeholder with primary intrest in use case (usually the one triggering the use case).\n\n\nSupporting actors\n\n\nActors also envolved\n\n\n\n\nSome stakeholders may not be participating in a use case (so neither primary or supporting actors).\n\n\nActors can be:\n\n\n\n\nUsers of a system\n\n\nAn external system, which interacts with the system\n\n\n\n\nUsually a use case is a sequence of steps, however they may other paths, they may succeed, fail, or succeed in an alternate way.\n\n\nExample\n\n\nMain success scenario\n\n\n1. Customer selects item\n2. Customer checks out\n3. ...\n4. Email confirmation\n\n\n\n\nExtensions - variations of the maun success scenario\n\n\n6a. Credit card auth fails\n    .1 Re-enter details\n\n\n\n\nUse case templates\n\n\n\n\nGoal:\n What the primary actor wishes to acheive\n\n\nSummary:\n Description of use case\n\n\nStakeholders and each\u2019s Interest in the use case\n\n\nPrimary actor\n\n\nSupporting actors\n\n\nTrigger:\n The event that leads to this use case being performed.\n\n\nPre-conditions/Assumptions:\n What can be assumed to be true when the use case starts\n\n\nGuarantees:\n What the use case ensures at its end\n\n\nSuccess guarantees\n\n\nFailure guarantees\n\n\nMinimal guarantees\n\n\n\n\n\n\nMain Success Scenario\n\n\nAlternative scenarios\n\n\n\n\nA use case can:\n- Diffrent levels of detail\n    - Depending on part of development process\n- May refer to other use cases\n- Descripe diffrent scopes\n\n\nRequirements capture\n\n\n\n\nIdentify actors\n\n\nFor each actor\n\n\nWhat do they need\n\n\nAny other expected interactions\n\n\nWhich use cases have priority\n\n\n\n\n\n\n\n\nUse cases are often functional requirements, with non-functional requirements attached. Other times. Non-functional requirements apply to subsets or all of use-cases.\n\n\nOther uses\n\n\n\n\nDrive design\n\n\nDesign validation\n\n\nDoes the design work\n\n\n\n\n\n\nTesting\n\n\nGood source for system tests\n\n\n\n\n\n\n\n\nProblems\n\n\n\n\nMay be to much detail (constraining design)\n\n\nSupporting actors may not be strictly necessary i.e. librarian may not be involved in borrowing a book (in a modern library)\n\n\nLess attension to architecture and static object structure.\n\n\nMay miss requirements not associated with actors.\n\n\n\n\nDesign\n\n\n\n\nDesign\n\n\nHow softawre will meet the requirements\n\n\n\n\nOutputs of design:\n\n\n\n\nModels\n\n\nUML / SImulink\n\n\nOften graphical\n\n\nCan be executable\n\n\n\n\n\n\nWritten documents\n\n\nRecord reasons for decisions (\n\n\ntrace back when problem occors to relevent stakeholder\n\n\n\n\n\n\n\n\nCriteria:\n\n\n\n\nThe design can meet the requirements\n\n\nIs it maintainable?\n\n\nCan it be explained to implementors\n\n\nFits constraints of exsisting technology (legacy components)\n\n\nMakes future design choices easy\n\n\n\n\n\n\nHigh level (architectural) design\n\n\nHow subsytems are split up\n\n\nLow level (detailed) design\n\n\nHow subsystems are composed\n\n\n\n\nAt each level:\n\n\n\n\nWhat are the responsibilities of each component?\n\n\nwhat are the interfaces?\n\n\nWhat are the messages exchanged (what protocols)?\n\n\n\n\n\n\nArchitecture\n\n\nThe way that components work together.\n\n\n\n\n\n\n\n\nWhat are the components\n\n\n\n\nWhere shall we put the encapsulation barriers?\n\n\nWhich decisions do we want to hide inside components (so they can be changed without effecting the rest of the system)?\n\n\n\n\n\n\n\n\nWhat are the connectors?\n\n\n\n\nHow/what do the components need to communicate?\n\n\nWhat should be the interfaces?\n\n\nWhat protocols should be used?\n\n\n\n\n\n\n\n\nMore architecutral decisions:\n\n\n\n\nWhat language and/or component standard is going to be used?\n\n\nIs their an appropriate exising framework?\n\n\nWhat conventions for error handling?\n\n\nbackups\n\n\nresiliance\n\n\nfail gracefully\n\n\n\n\n\n\n\n\nDetailed design\n\n\n\n\nArchitecture has be designed\n\n\nEach person/team is in charge of designing one subsystem\n\n\nWhat external interfaces must it work with?\n\n\nWhat classes and behaviour are needed?\n\n\nCoordination with system architect to change interface if required.\n\n\n\n\nPrinciples\n\n\n\n\nCohesion\n\n\nA mesure of the strenth o fthe realationship between the pieces of functionality within the component. High cohesion has increased understandability, maintainability and reliability.\n\n\nCoupling\n\n\nA mesure of the strength of the inter-connection between components. Loose coupling increases understandability and maintainablilty.\n\n\nAbstraction\n\n\nA view of some entity that focuses on the infomation relevent to a particular purpose.\n\n\nEncapsulation\n\n\nGrouping and packaging the elements and internal details of an abstraction and making those details inaccessible.\n\n\nSeperation of interface/implementation\n\n\nSpecifing a public interface, known to the clients, separate from the details of how the component is realized.\n\n\nDecomposition\n\n\nDivinding large systems into smaller components with distinct responsibilitys.\n\n\n\n\nModeling\n\n\n\n\nModel\n\n\nA precise represntation of some of the information needed to solve a problem using a computer.\n\n\n\n\nA UML model\n- represented by set of diagrams\n- structured represnetation too (XML)\n- must obey rules of UML standard\n- (fairly) precise meaning\n- Used informally (talking around whiteboard)\n\n\nBig design up front\n\n\n\n\nOften unavoidable\n\n\nIf done right, simplifys developent\n\n\nError prone (changing requirements)\n\n\nWastefull (mistakes in requirements)\n\n\n\n\nXP maxinms:\n- You aint going to need it\n- Do the simplest thing that could possibly work",
            "title": "Introduction to Software Engineering"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#use-cases",
            "text": "Use case  A task involving the system which has value for one or more stakeholders.  Actors  A stakeholder who takes an active part in the use case.  Primary Actor  Stakeholder with primary intrest in use case (usually the one triggering the use case).  Supporting actors  Actors also envolved   Some stakeholders may not be participating in a use case (so neither primary or supporting actors).  Actors can be:   Users of a system  An external system, which interacts with the system   Usually a use case is a sequence of steps, however they may other paths, they may succeed, fail, or succeed in an alternate way.",
            "title": "Use Cases"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#example",
            "text": "Main success scenario  1. Customer selects item\n2. Customer checks out\n3. ...\n4. Email confirmation  Extensions - variations of the maun success scenario  6a. Credit card auth fails\n    .1 Re-enter details",
            "title": "Example"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#use-case-templates",
            "text": "Goal:  What the primary actor wishes to acheive  Summary:  Description of use case  Stakeholders and each\u2019s Interest in the use case  Primary actor  Supporting actors  Trigger:  The event that leads to this use case being performed.  Pre-conditions/Assumptions:  What can be assumed to be true when the use case starts  Guarantees:  What the use case ensures at its end  Success guarantees  Failure guarantees  Minimal guarantees    Main Success Scenario  Alternative scenarios   A use case can:\n- Diffrent levels of detail\n    - Depending on part of development process\n- May refer to other use cases\n- Descripe diffrent scopes",
            "title": "Use case templates"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#requirements-capture",
            "text": "Identify actors  For each actor  What do they need  Any other expected interactions  Which use cases have priority     Use cases are often functional requirements, with non-functional requirements attached. Other times. Non-functional requirements apply to subsets or all of use-cases.",
            "title": "Requirements capture"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#other-uses",
            "text": "Drive design  Design validation  Does the design work    Testing  Good source for system tests",
            "title": "Other uses"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#problems",
            "text": "May be to much detail (constraining design)  Supporting actors may not be strictly necessary i.e. librarian may not be involved in borrowing a book (in a modern library)  Less attension to architecture and static object structure.  May miss requirements not associated with actors.",
            "title": "Problems"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#design",
            "text": "Design  How softawre will meet the requirements   Outputs of design:   Models  UML / SImulink  Often graphical  Can be executable    Written documents  Record reasons for decisions (  trace back when problem occors to relevent stakeholder     Criteria:   The design can meet the requirements  Is it maintainable?  Can it be explained to implementors  Fits constraints of exsisting technology (legacy components)  Makes future design choices easy    High level (architectural) design  How subsytems are split up  Low level (detailed) design  How subsystems are composed   At each level:   What are the responsibilities of each component?  what are the interfaces?  What are the messages exchanged (what protocols)?    Architecture  The way that components work together.     What are the components   Where shall we put the encapsulation barriers?  Which decisions do we want to hide inside components (so they can be changed without effecting the rest of the system)?     What are the connectors?   How/what do the components need to communicate?  What should be the interfaces?  What protocols should be used?",
            "title": "Design"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#more-architecutral-decisions",
            "text": "What language and/or component standard is going to be used?  Is their an appropriate exising framework?  What conventions for error handling?  backups  resiliance  fail gracefully",
            "title": "More architecutral decisions:"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#detailed-design",
            "text": "Architecture has be designed  Each person/team is in charge of designing one subsystem  What external interfaces must it work with?  What classes and behaviour are needed?  Coordination with system architect to change interface if required.",
            "title": "Detailed design"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#principles",
            "text": "Cohesion  A mesure of the strenth o fthe realationship between the pieces of functionality within the component. High cohesion has increased understandability, maintainability and reliability.  Coupling  A mesure of the strength of the inter-connection between components. Loose coupling increases understandability and maintainablilty.  Abstraction  A view of some entity that focuses on the infomation relevent to a particular purpose.  Encapsulation  Grouping and packaging the elements and internal details of an abstraction and making those details inaccessible.  Seperation of interface/implementation  Specifing a public interface, known to the clients, separate from the details of how the component is realized.  Decomposition  Divinding large systems into smaller components with distinct responsibilitys.",
            "title": "Principles"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#modeling",
            "text": "Model  A precise represntation of some of the information needed to solve a problem using a computer.   A UML model\n- represented by set of diagrams\n- structured represnetation too (XML)\n- must obey rules of UML standard\n- (fairly) precise meaning\n- Used informally (talking around whiteboard)",
            "title": "Modeling"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#big-design-up-front",
            "text": "Often unavoidable  If done right, simplifys developent  Error prone (changing requirements)  Wastefull (mistakes in requirements)   XP maxinms:\n- You aint going to need it\n- Do the simplest thing that could possibly work",
            "title": "Big design up front"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/",
            "text": "Closure Properties of Regular Languages\n\n\n$\\epsilon$-NFA\n\n\nIf we allow $\\epsilon$ transitions, which represents an instananious transition, NFA's can be transformed to have one start and one accepting state.\n\n\nThis doesnt increase the power of NFA's, but it has some convenience.\n\n\nConcatination\n\n\n$L_1 . L_2 = {xy | x \\in L_1, y \\in L_2}$\n\n\n$L_1 . L_2$ is the concatination of two languages, for example ${a, b}$, ${c, d}$ becomes ${ac, ad, bc, bd}$\n\n\nIts obvious the concatination is closed, since we can add an $\\epsilon$ transition between the start and accepting states of the machines for languages $L_1$ and $L_2$\n\n\nKleene star\n\n\n$L* = {\\epsilon} \\cup L \\cup L.L \\cup ...$\n\n\n$L*$ Is the langauge of 0 or more strings of $L$\n\n\nAgain kleene start is also closed. By introducing a new start state with an $\\epsilon$ transition to the machine for $L$ and add a $\\epsilon$ transition back from the machine to the new accepting state. This allows the machine for $L$ to run for any amount of times.\n\n\nRegular Expressions\n\n\nRegular expressions are a language for defining languages.\n\n\n\n\n\n\n\n\nSymbol\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\n$\\emptyset$\n\n\n$L(\\emptyset) = \\emptyset$\n\n\n\n\n\n\n$\\epsilon$\n\n\n$L(\\epsilon) = {\\epsilon}$\n\n\n\n\n\n\n$a$ (for $a \\in \\sum$)\n\n\n$L(a) = {a}$\n\n\n\n\n\n\n$+$\n\n\n$L(a+b) = L(a) \\cup L(b)$\n\n\n\n\n\n\n$.$\n\n\n$L(a.b) = L(a) . L(b)$\n\n\n\n\n\n\n$*$\n\n\n$L(a\n) = L(a)\n$\n\n\n\n\n\n\n\n\nOrder\n\n\nIn the absence of brackets the order of operation is as follows:\n\n\n\n\n$*$\n\n\n$.$\n\n\n$+$\n\n\n\n\nKleene's Theorem\n\n\nKleene's Theorem:\n DFA's and regular expressions give rise to exactly the same class of langauges (the regular langauges)\n\n\nSo regular languages can be defined as regular expressions.\n\n\nKleene algebra\n\n\nRegular expressions can be manipulated with kleene algebra without changing the language\n\n\n\n\n$a + (b + c) = (a + b) + c$\n\n\n$a + \\emptyset$\n\n\n...\n\n\n$\\epsilon + aa\n = \\epsilon + a * a = a\n$",
            "title": "Processing Formal and Natural Languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#closure-properties-of-regular-languages",
            "text": "",
            "title": "Closure Properties of Regular Languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#epsilon-nfa",
            "text": "If we allow $\\epsilon$ transitions, which represents an instananious transition, NFA's can be transformed to have one start and one accepting state.  This doesnt increase the power of NFA's, but it has some convenience.",
            "title": "$\\epsilon$-NFA"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#concatination",
            "text": "$L_1 . L_2 = {xy | x \\in L_1, y \\in L_2}$  $L_1 . L_2$ is the concatination of two languages, for example ${a, b}$, ${c, d}$ becomes ${ac, ad, bc, bd}$  Its obvious the concatination is closed, since we can add an $\\epsilon$ transition between the start and accepting states of the machines for languages $L_1$ and $L_2$",
            "title": "Concatination"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleene-star",
            "text": "$L* = {\\epsilon} \\cup L \\cup L.L \\cup ...$  $L*$ Is the langauge of 0 or more strings of $L$  Again kleene start is also closed. By introducing a new start state with an $\\epsilon$ transition to the machine for $L$ and add a $\\epsilon$ transition back from the machine to the new accepting state. This allows the machine for $L$ to run for any amount of times.",
            "title": "Kleene star"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#regular-expressions",
            "text": "Regular expressions are a language for defining languages.     Symbol  Definition      $\\emptyset$  $L(\\emptyset) = \\emptyset$    $\\epsilon$  $L(\\epsilon) = {\\epsilon}$    $a$ (for $a \\in \\sum$)  $L(a) = {a}$    $+$  $L(a+b) = L(a) \\cup L(b)$    $.$  $L(a.b) = L(a) . L(b)$    $*$  $L(a ) = L(a) $",
            "title": "Regular Expressions"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#order",
            "text": "In the absence of brackets the order of operation is as follows:   $*$  $.$  $+$",
            "title": "Order"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleenes-theorem",
            "text": "Kleene's Theorem:  DFA's and regular expressions give rise to exactly the same class of langauges (the regular langauges)  So regular languages can be defined as regular expressions.",
            "title": "Kleene's Theorem"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleene-algebra",
            "text": "Regular expressions can be manipulated with kleene algebra without changing the language   $a + (b + c) = (a + b) + c$  $a + \\emptyset$  ...  $\\epsilon + aa  = \\epsilon + a * a = a $",
            "title": "Kleene algebra"
        }
    ]
}