{
    "docs": [
        {
            "location": "/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nInfomatics Notes",
            "title": "Home"
        },
        {
            "location": "/#infomatics-notes",
            "text": "",
            "title": "Infomatics Notes"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nPropositonal Logic\n\n\nPropositions\n\n\n\n\nProposition\n\n\nA declarative sentence (declares a fact) that is either true or false.\n\n\n\n\n\n\n\n\n\n\nPropositon\n\n\nNot propositions\n\n\n\n\n\n\n\n\n\n\nIt is raining.\n\n\nWhat is the data?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLogical operators\n\n\nFrom these propositions we can from new compound propositions with logical operators:\n\n\n\n\n\n\n\n\nOperation\n\n\nExample\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nNegation\n\n\n\n\nit is not the case that \n\n\n\n\n\n\nConjunction\n\n\n\n\nboth \n and \n must be true for \n to be true\n\n\n\n\n\n\nDisjunction\n\n\n\n\nFalse when both \n and \n are false, true otherwise\n\n\n\n\n\n\nExclusive Or\n\n\n\n\nEither \n or \n must be true (\nnot both\n) for \n to be true\n\n\n\n\n\n\nImplication\n\n\n\n\nFalse when \n is true and \n is false, true otherwise. \n is the hypothesis/antecedent and \n is the conclusion/conseqence\n\n\n\n\n\n\nBiconditional\n\n\n\n\n if and only if \n, true when both \n and \n have the same truth values\n\n\n\n\n\n\n\n\nTruth tables\n\n\nWith these logical operators we can build complex logical statements such as: \n. To construct truth tables for these expressions we start with the individual variables \n and \n, and solve sub expressions until we reach the full expression.\n\n\n\n\nOperator precedence\n\n\nThe order of which operators apply are as follows:\n\n\n\n\n\n\n\n\nOperator\n\n\nPrecedence\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\n\n2\n\n\n\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\n4\n\n\n\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\nLogical Equivalences\n\n\n\n\nTautology\n\n\nA compound proposition that is \ntrue\n, no matter what values the propositional variables hold.\n\n\nContradiction\n\n\nA compound proposition that is \nfalse\n, no matter what values the propositional variables hold.\n\n\nContingency\n\n\nCompound propositions that are neither a tautology or a contradiction.\n\n\n\n\n\n\n is a tautology\n\n\n is a contradiction\n\n\n is a contingency\n\n\n\n\nTwo compound propositions are \nlogically equivilent\n if they have the same truth values in all cases. This occors when \n is a tautology, where \n and \n are compound propositions. \n is a statement, denoting that \n and \n are logically equivilent.\n\n\nImportant Equivalences\n\n\n\n\n\n\n\n\nEquivalence\n\n\nName\n\n\n\n\n\n\n\n\n\n\n\n\nIdentity laws\n\n\n\n\n\n\n\n\nDomination laws\n\n\n\n\n\n\n\n\nIdempotent laws\n\n\n\n\n\n\n\n\nDouble negation law\n\n\n\n\n\n\n\n\nCommutative laws\n\n\n\n\n\n\n\n\nAssociative laws\n\n\n\n\n\n\n\n\nDistributive laws\n\n\n\n\n\n\n\n\nDe Morgan's laws\n\n\n\n\n\n\n\n\nAbsorption laws\n\n\n\n\n\n\n\n\nNegation laws\n\n\n\n\n\n\n\n\nLogical equivalences involving conditional statements\n\n\n\n\n\n\n\n\nLogical equivalences involving biconditionals\n\n\n\n\n\n\n\n\nNotation\n\n\nSimular to \n, their exsists a notation for \n and \n.\n\n\n\n\n\n\nConstructing new logical equivalences\n\n\nUsing equivalences we already know, we can prove expressions are tautologys or that two expressions are logically equivelent. While a truth table could also be used, it is much shorted to apply laws.\n\n\n\n\nShow that \n is a tautology.\n\n\n\n\n\nSatisfaction\n\n\n\n\nSatisfiable\n\n\nA compound proposition were there \nis a\n assignment of truth values that make it true.\n\n\nUnsatisfiable\n\n\nA compound proposition were there \nis no\n assignment of truth values that make it true.\n\n\n\n\nThe values which make a compound proposition true is called the \nsolution to the satisfiability problem\n.\n\n\nPredicates and Quantifiers\n\n\nPredicates\n\n\nStatements that involve variables such as \n and \n are undecided when their variables are not given a value. We need a more powerfull logic, \npredicate logic\n, to model these statements.\n\n\nWe turn the statement \n into the predicate \n where \n is \n. When we give \n a value, the statement becomes a proposition, e.g. \n becomes \n which is \n.\n\n\nA predicate can have any number of variables, \n. A predicate with \n variables is called an \n-ary predicate.\n\n\nQuantifiers\n\n\nAssigning variables is not the only way to form a proposition from a predicate. \nQuantification\n expresses the extend to which a predicate is true over a range.\n\n\n\n\n\n\n\n\nName\n\n\nExample\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nUniversal quantifier\n\n\n\n\nis true if \n is true for all x (domain)\n\n\n\n\n\n\nExistential quantifier\n\n\n\n\nis true if \n is true for at least one value in the domain\n\n\n\n\n\n\n\n\n\n\nIs \n where the domain is all real numbers true.\n\n\nNo, if \n, \n) is false, thus not all elements in the domain make \n true.\n\n\n\n\nRestricting the domain\n\n\nConsider \n where the domain of \n is \n. We could express that as:\n\n\n\n\nTheir is a shorter notation for restricting the domain\n\n\n\n\nPrecedence of Quantifiers\n\n\n and \n have a higher precedence that all other logical operators.\n\n\nBinding Variables\n\n\nWhen a quantifier is used on variable, or the variable is assigned a value, the variable is said to be \nbound\n. Predicates must have all the variables bound to be turned into a proposition. Variables that are not bound are \nfree\n.\n\n\nThe \nscope\n of a quantifier is the part of the logical expression to which it is applied, hence variables outside of the scope of all quantifiers are free (if their value has not been assigned).\n\n\nLogical Equivalence\n\n\nTwo expressions involving predicates and quantifiers are equal if their truth values are the same throughout the domain.\n\n\n\n\nShow that \n and \n are logically equivalent.\n\n\n\n\nLet \n be some element in the domain, thus \n must be \n.\n\n\nIf \n is \n, \n and \n must both be \n.\n\n\nSince \n and \n are \n for all element in the domain, \n must also be $\\top$.\n\n\n\n\nSo\n\n\n\n\n\nNegation\n\n\n\n\n\n\n\n\nStatement\n\n\nEquivalent\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTheir is an \n for which \n is \n\n\n\n\n\n\n\n\n\n\nFor every \n, \n is \n\n\n\n\n\n\n\n\n\n\nProve \n\n\n\n\n is \n, if and only if \n is \n\n\nIf \n is \n, then their is atleast one element in the domain for which \n is true.\n\n\nIt follows then the \n\n\n\n\n\n\nNested Quantifiers\n\n\nMore complex statements often involve more than one quantifier. For example the logical statement that \nif \n is positive and \n is negative, \n is negative\n can be expressed as:\n\n\n\n\nProof\n\n\nRules of Inference\n\n\nProofs are mathmatical arguments that determine the truth of a statement. \nBy an argument\n, means a sequence of statements that end in a conclusion. \nBy valid\n, means the conclusion must follow from the arguments. \nBy premise\n, means the argument is valid if and only if it is impossible for all premises to be true and the conclusion false.\n\n\nAn \nargument\n is propositional logic is a sequence of propositons, where the final proposition is the conclusion and all others are the premises. An \nargument form\n in propositional logic is a sequence of compound propositions that is \nvalid\n no matter what propositions are substitude for a premise, so long as the premises are true.\n\n\nThe \nmodus ponens\n (law of detachment) is one rule we can use to proof statements. \n\n\n\n\n\nLet \n be \"it snows\" and \n be \"will go skiing\", if \"we will go skiing if it snows\" is \"we will go skiing\" true?\n\n\n\n\n\n\n\n\n\n\n\n\nRule of Inference\n\n\nTautology\n\n\nName\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModus ponens\n\n\n\n\n\n\n\n\n\n\nModus tollens\n\n\n\n\n\n\n\n\n\n\nHypothetical syllogism\n\n\n\n\n\n\n\n\n\n\nDisjunctive syllogism\n\n\n\n\n\n\n\n\n\n\nAddition\n\n\n\n\n\n\n\n\n\n\nSimplification\n\n\n\n\n\n\n\n\n\n\nConjunction\n\n\n\n\n\n\n\n\n\n\nResolution\n\n\n\n\n\n\n\n\nUsing Rules of Inference to Build Arguments\n\n\n\n\nGiven the premesis: \n, \n, \n, \n find an argument that shows the premisies lead to the conclusion \n.\n\n\n\n\n\n\nFallacies\n\n\n is a tautology, fallacies often look like tautologys but are just contingencies:\n\n\n\n\nFallacy of affirming the conclusion\n\n\noccors when \n is treated as a tautology, but it is false when \n is false and \n is true.\n\n\nFallacy of denying the hypothesis\n\n\noccors when \n is treated as a tautology, but it is false when \n is false and \n is true.\n\n\n\n\nRules of Inference for Quantified Statements\n\n\n\n\n\n\n\n\nRule of Inference\n\n\nName\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n\n\nUniversal instantiation\n\n\n is true, where \n is an element of the domain, since all elements are true.\n\n\n\n\n\n\n\n\nUniversal generalization\n\n\n is true, if \n (where \n is an arbitary element in the domain) is true. Since we do not make any assumptions about \n, other than its an element of the domain, all values of the domain must be true.\n\n\n\n\n\n\n\n\nExistential instantiation\n\n\nTheir is an element \n in the domain that makes \n true. Note \n is not arbitary since some elements in the domain do not make \n true.\n\n\n\n\n\n\n\n\nExistential generalization\n\n\nIf we know one element \n in the domain that makes \n true, then it follows that \n\n\n\n\n\n\n\n\n\n\nShow that the premesis \"A student in the class has not read the book\" and \"Everyone in the class passed the exam\" implys the conclusion that \"Someone who passed the exam had not read the book\"\n\n\n\n\nLet \n be \"\n is in the class\"\n\n\nLet \n be \"\n passed the exam\"\n\n\nLet \n be \"\n has read the book\"\n\n\n\n\n\n\n\n\nSets, Functions, Relations, Sequences and Sums\n\n\nSet\n\n\n\n\nSet\n\n\nAn unordered collection of elements\n\n\n\n\nSet Operations\n\n\n\n\n\n\n\n\nName\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nEquality\n\n\n\n\n\n\n\n\nMembership\n\n\n\n\n\n\n\n\nNon-Membership\n\n\n\n\n\n\n\n\nEmpty Set\n\n\n\n\n\n\n\n\nUnion\n\n\n\n\n\n\n\n\nIntersection\n\n\n\n\n\n\n\n\nDiffrence\n\n\n\n\n\n\n\n\nComplement\n\n\n\n\n\n\n\n\nSubset\n\n\n\n\n\n\n\n\nSuperset\n\n\n\n\n\n\n\n\nPower Set\n\n\n (set of all subsets)\n\n\n\n\n\n\nCardinality\n\n\n\n\n\n\n\n\nCartesian Product\n\n\n\n\n\n\n\n\n\n\nCommon Sets\n\n\n\n\n\n\n\n\nName\n\n\nSymbol\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBooleans\n\n\n\n\n\n\n\n\n\n\nNatural numbers\n\n\n\n\n\n\n\n\n\n\nInteger\n\n\n\n\n\n\n\n\n\n\nPositive Integers\n\n\n\n\n\n\n\n\n\n\nReal Numbers\n\n\n\n\n\n\n\n\n\n\nRational\n\n\n\n\n\n\n\n\n\n\nComplex Numbers\n\n\n\n\n\n\n\n\n\n\n\n\nSet Identitys\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions\n\n\nSyntax\n\n\n\n\nFunction\n\n\nA function \n from set \n to set \n assigns an element from \n to \n, this is written as \n.\n\n\n\n\nExamples:\n\n\n\n\nCeil - \n\n\nFloor - \n\n\nIdentity - \n\n\nFactorial - \n\n\n\n\n\n\n\n\n\n\nType of function\n\n\nCondition\n\n\nExamples\n\n\n\n\n\n\n\n\n\n\nInjective\n\n\n\n\n, \n\n\n\n\n\n\nSurjective\n\n\n\n\n, \n\n\n\n\n\n\nBijection\n\n\nInjective and surjective\n\n\n, \n\n\n\n\n\n\n\n\nComposition\n\n\nLet \n and \n. The composition function \n is \n\n\n\n\nThe composition of two functions is a function\n\n\nThe composition of two injective functions is a injective function\n\n\nThe composition of two surjective functions is a surjective function\n\n\nThe composition of two bijections is a bijection\n\n\n\n\nInverse\n\n\nIf \n is a bijection, then the inverse of \n, written \n is \n iff \n\n\n\n\nInverse of the identity function, is the identity function\n\n\nInverse of \n is \n \n\n\n and \n is the identity function\n\n\n\n\nRelations\n\n\nA binary relation \n on sets \n and \n is a subset \n\n\n\n\nOften written as \n for \n\n\nA function \n is a restricted relation where \n\n\nFor all a in \n their exsists a \n in \n\n\nwhere (a, b) in relation \n\n\nand \n is unique  \n\n\n\n\n\n\nGiven sets \n a subset \n is an \n-ary relation.\n\n\n\n\n where \n is students and \n is courses, \n\n\nRelation composition\n\n\nLet \n and \n. The composition relation \n is \n\n\nThe expression specifys the relations where \n and \n have a common \n, thus \n\n\nClosure \n is a relation on \n:\n\n\n\n\n is the identity relation \n\n\n\n\n\n\n\n\nTypes of relation\n\n\n\n\n\n\n\n\nType of relation\n\n\nCondition\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nReflexive\n\n\n\n\n, \n\n\n\n\n\n\nSymetric\n\n\n\n\n\n\n\n\n\n\nAntisymetric\n\n\n\n\n, \n, \n\n\n\n\n\n\nTransitive\n\n\n\n\n, \n, \n\n\n\n\n\n\nEquivalance\n\n\nReflexive, symetric and transitive\n\n\n\n\n\n\n\n\n\n\nEquivalance classes\n\n\nLet \n be an equivalence realtion on a set \n and \n let \n be the equivalance class of a w.r.t \n.\n\n\nIf \n the \n is called a representative of the equivalance class.\n\n\nLet \n be an equivalance realtion on \n amd \n. Then following statements are equivalnet\n\n\n\n\n\n\n\n\n\n\n\n\nPartitions of a Set\n\n\nA partition of set \n is a collection of disjoint, nonempty subsets that have \n as their union, in other words the collection of subsets \n with \n (where \n is the index set) forms a partition of \n iff\n\n\n\n\n for all \n\n\n for all \n\n\n\n\n\n\nFrom this can see:\n\n\n\n\nIf \n is an equivalance class on \n, then the equivalance classes of \n form a partion of \n.\n\n\nConversly, given a partition \n of \n, there exsists an equivalance relation \n that has the sets \n, \n, as its equivalence classes.\n\n\n\n\nSequences\n\n\n\n\nSequence\n\n\nOrdered list of elements for example, \n is \n defines the sequence \n\n\nGeometric progressions\n\n\nA sequence in the form \n\n\nArithmetic progressions\n\n\nA sequence in the form \n\n\n\n\nRecurrence relations\n\n\n\n\nRecurrence relations\n\n\nA recurance relations for \n is an equation that expreses \n in terms of one or more elements of \n\n\n\n\n\n\nAfter 1 month a pair of rabbits is placed on an island\n\n\nAfter every 2 months, each pair of rabbits produces a new pait of rabbits \n\n\n\n\nThe realtion is:\n\n\n\nSolving a recurrence relations if finding the nth term, one way of solving is an iterative aproach\n\n\n\n\nSupose a person deposits $1000 in savings with 3 percent intrest, how much is the account worth after 20 years\n\n\n\n\nLet \n denote the amount after \n years\n\n\n\n\n\n\n\n\n\n\n\n\nSumations\n\n\nGiven a sequence \n, the sum of the terms is \n\n\n\nUsefull sumations\n\n\n\n\n\n\n\n\nSum\n\n\nClosed form\n\n\n\n\n\n\n\n\n\n\n\n\n, \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProduct\n\n\nGiven a sequence \n, the product of the terms is \n\n\n\nor more generally for a finite index set \n, \n\n\n\nCartinality\n\n\n\n\nFinite set\n\n\nA set \n is finite with cardinality \n if there is a bijection from the set \n to \n.\n\n\nInfinite set\n\n\nA set that is not finite\n\n\n\n\n\n\nProve the set of natural numbers, \n, is an infinite set.\n\n\n\n\nConsider the function \n defined as \n\n\n is injective, since every element in the domain has an element in the codomain which is mapped to it.\n\n\n is not subjective, since \n is in the codomain but is has no element in the domain which maps to it.\n\n\nThus \n is not a bijection.\n\n\nThus \n is an infinite set.\n\n\n\n\n\n\nCountable sets\n\n\n\n\nCountable\n\n\nA set that is either finite or has the same cardinality as the set of the positive integers\n\n\nUncountable\n\n\nA set that is not countable\n\n\n\n\nAn infinite set \n is countable, we denote the cardinality of \n by \n \n\n\n\n\nIf \n and \n are countable sets, then \n is also countable\n\n\nIf \n is countable and for each \n the set \n is countable then \n is countable\n\n\n\n\n\n\nShow that the set of real numbers is uncountable \n\n\n\n\nAssume that the set of real numbers is countable\n\n\nThe the real numbers between \n and \n must also be countable\n\n\nWe can list these numbers with decimal noation \n\n\nWhere \n\n\nWe can define a number \n\n\nWhere \n\n\nSo \n defines a number that is diffrent from \n in the \n number\n\n\nThus their is a real number between \n and \n that is not in the list\n\n\nTherefore the set of real numbers cannot be listed.\n\n\n\n\n\n\nSchr\u00f6der-Bernstein Theorem\n\n\nIf \n and \n are sets with \n and \n, then \n. In other words, if there are one-to-one functions \n from \n to \n and \n from \n to \n, then there is a one-to-one correspondence between \n and \n.\n\n\n\n\nShow that \n\n\n\n\nSince \n, their is a one-to-one function from \n to \n\n\nLets define \n, which is a mapping from \n to \n, \n so their is a one \n to \n.\n\n\nThus \n, due to Schr\u00f6der-Bernstein Theorem\n\n\n\n\n\n\nCantor\u2019s theorem\n\n\n\n\n\n\nProof\n\n\n\n\nConsider the injection \n with \n for any \n.\n\n\nTherefore \n\n\nAssume a surjection \n exsists\n\n\nLet \n\n\nSince \n is a surjection, there must exist an \n such that \n\n\nIf \n then by definition of \n, \n (contradiction)\n\n\nIf \n then \n, by definition of \n, \n (contradiction)\n\n\n\n\n\n\n\n\n\n\nOne consequence of cantors theorem is that their is an infinite hierarchy of sets of larger cardinality.\n\n\nInduction\n\n\n\n\nMathematical Induction\n\n\nTo prove \n is true for all positive integers, where \n is a propositional function\n\n\nBasic Step\n\n\nVerifying \n is true\n\n\nInductive step\n\n\nShowing that the conditional \n is true for all positive integers \n\n\n\n\n\n\nProve that if \n is a positive integer \n\n\n\n\n, thus \n\n\nAssuming \n holds, then it must be shown that \n holds \n\n\nThus if we can show \n, then \n\n\n\n\n\n\n\n\nStrong induction\n\n\n\n\nMathematical Strong Induction\n\n\nTo prove \n is true for all positive integers, where \n is a propositional function\n\n\nBasic Step\n\n\nVerifying \n is true\n\n\nInductive step\n\n\nShowing that the conditional \n is true for all positive integers \n\n\n\n\n\n\nProve that if \n, then \n can be written as the product of primes\n\n\n\n\n is true since \n (\n is a prime itself).\n\n\n is either a prime or a composite number\n\n\nIf it is prime, then itself is a product of primes\n\n\nIf it is composite, then \n is the product of two positive integers \n and \n that are \n.\n\n\nThus since both are less than \n, by strong induction they can be rewritten as the product of primes\n\n\nThus \n can be written as the product of primes",
            "title": "Discrete Mathmatics and Mathmatical Reasoning"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#propositonal-logic",
            "text": "",
            "title": "Propositonal Logic"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#propositions",
            "text": "Proposition  A declarative sentence (declares a fact) that is either true or false.      Propositon  Not propositions      It is raining.  What is the data?",
            "title": "Propositions"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-operators",
            "text": "From these propositions we can from new compound propositions with logical operators:     Operation  Example  Explanation      Negation   it is not the case that     Conjunction   both   and   must be true for   to be true    Disjunction   False when both   and   are false, true otherwise    Exclusive Or   Either   or   must be true ( not both ) for   to be true    Implication   False when   is true and   is false, true otherwise.   is the hypothesis/antecedent and   is the conclusion/conseqence    Biconditional    if and only if  , true when both   and   have the same truth values",
            "title": "Logical operators"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#truth-tables",
            "text": "With these logical operators we can build complex logical statements such as:  . To construct truth tables for these expressions we start with the individual variables   and  , and solve sub expressions until we reach the full expression.",
            "title": "Truth tables"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#operator-precedence",
            "text": "The order of which operators apply are as follows:     Operator  Precedence       1     2     3     4     5",
            "title": "Operator precedence"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-equivalences",
            "text": "Tautology  A compound proposition that is  true , no matter what values the propositional variables hold.  Contradiction  A compound proposition that is  false , no matter what values the propositional variables hold.  Contingency  Compound propositions that are neither a tautology or a contradiction.     is a tautology   is a contradiction   is a contingency   Two compound propositions are  logically equivilent  if they have the same truth values in all cases. This occors when   is a tautology, where   and   are compound propositions.   is a statement, denoting that   and   are logically equivilent.",
            "title": "Logical Equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#important-equivalences",
            "text": "Equivalence  Name       Identity laws     Domination laws     Idempotent laws     Double negation law     Commutative laws     Associative laws     Distributive laws     De Morgan's laws     Absorption laws     Negation laws     Logical equivalences involving conditional statements     Logical equivalences involving biconditionals",
            "title": "Important Equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#notation",
            "text": "Simular to  , their exsists a notation for   and  .",
            "title": "Notation"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#constructing-new-logical-equivalences",
            "text": "Using equivalences we already know, we can prove expressions are tautologys or that two expressions are logically equivelent. While a truth table could also be used, it is much shorted to apply laws.   Show that   is a tautology.",
            "title": "Constructing new logical equivalences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#satisfaction",
            "text": "Satisfiable  A compound proposition were there  is a  assignment of truth values that make it true.  Unsatisfiable  A compound proposition were there  is no  assignment of truth values that make it true.   The values which make a compound proposition true is called the  solution to the satisfiability problem .",
            "title": "Satisfaction"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#predicates-and-quantifiers",
            "text": "",
            "title": "Predicates and Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#predicates",
            "text": "Statements that involve variables such as   and   are undecided when their variables are not given a value. We need a more powerfull logic,  predicate logic , to model these statements.  We turn the statement   into the predicate   where   is  . When we give   a value, the statement becomes a proposition, e.g.   becomes   which is  .  A predicate can have any number of variables,  . A predicate with   variables is called an  -ary predicate.",
            "title": "Predicates"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#quantifiers",
            "text": "Assigning variables is not the only way to form a proposition from a predicate.  Quantification  expresses the extend to which a predicate is true over a range.     Name  Example  Note      Universal quantifier   is true if   is true for all x (domain)    Existential quantifier   is true if   is true for at least one value in the domain      Is   where the domain is all real numbers true.  No, if  ,  ) is false, thus not all elements in the domain make   true.",
            "title": "Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#restricting-the-domain",
            "text": "Consider   where the domain of   is  . We could express that as:   Their is a shorter notation for restricting the domain",
            "title": "Restricting the domain"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#precedence-of-quantifiers",
            "text": "and   have a higher precedence that all other logical operators.",
            "title": "Precedence of Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#binding-variables",
            "text": "When a quantifier is used on variable, or the variable is assigned a value, the variable is said to be  bound . Predicates must have all the variables bound to be turned into a proposition. Variables that are not bound are  free .  The  scope  of a quantifier is the part of the logical expression to which it is applied, hence variables outside of the scope of all quantifiers are free (if their value has not been assigned).",
            "title": "Binding Variables"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#logical-equivalence",
            "text": "Two expressions involving predicates and quantifiers are equal if their truth values are the same throughout the domain.   Show that   and   are logically equivalent.   Let   be some element in the domain, thus   must be  .  If   is  ,   and   must both be  .  Since   and   are   for all element in the domain,   must also be $\\top$.   So",
            "title": "Logical Equivalence"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#negation",
            "text": "Statement  Equivalent  Note        Their is an   for which   is       For every  ,   is       Prove     is  , if and only if   is   If   is  , then their is atleast one element in the domain for which   is true.  It follows then the",
            "title": "Negation"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#nested-quantifiers",
            "text": "More complex statements often involve more than one quantifier. For example the logical statement that  if   is positive and   is negative,   is negative  can be expressed as:",
            "title": "Nested Quantifiers"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#proof",
            "text": "",
            "title": "Proof"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#rules-of-inference",
            "text": "Proofs are mathmatical arguments that determine the truth of a statement.  By an argument , means a sequence of statements that end in a conclusion.  By valid , means the conclusion must follow from the arguments.  By premise , means the argument is valid if and only if it is impossible for all premises to be true and the conclusion false.  An  argument  is propositional logic is a sequence of propositons, where the final proposition is the conclusion and all others are the premises. An  argument form  in propositional logic is a sequence of compound propositions that is  valid  no matter what propositions are substitude for a premise, so long as the premises are true.  The  modus ponens  (law of detachment) is one rule we can use to proof statements.    Let   be \"it snows\" and   be \"will go skiing\", if \"we will go skiing if it snows\" is \"we will go skiing\" true?       Rule of Inference  Tautology  Name        Modus ponens      Modus tollens      Hypothetical syllogism      Disjunctive syllogism      Addition      Simplification      Conjunction      Resolution",
            "title": "Rules of Inference"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#using-rules-of-inference-to-build-arguments",
            "text": "Given the premesis:  ,  ,  ,   find an argument that shows the premisies lead to the conclusion  .",
            "title": "Using Rules of Inference to Build Arguments"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#fallacies",
            "text": "is a tautology, fallacies often look like tautologys but are just contingencies:   Fallacy of affirming the conclusion  occors when   is treated as a tautology, but it is false when   is false and   is true.  Fallacy of denying the hypothesis  occors when   is treated as a tautology, but it is false when   is false and   is true.",
            "title": "Fallacies"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#rules-of-inference-for-quantified-statements",
            "text": "Rule of Inference  Name  Notes       Universal instantiation   is true, where   is an element of the domain, since all elements are true.     Universal generalization   is true, if   (where   is an arbitary element in the domain) is true. Since we do not make any assumptions about  , other than its an element of the domain, all values of the domain must be true.     Existential instantiation  Their is an element   in the domain that makes   true. Note   is not arbitary since some elements in the domain do not make   true.     Existential generalization  If we know one element   in the domain that makes   true, then it follows that       Show that the premesis \"A student in the class has not read the book\" and \"Everyone in the class passed the exam\" implys the conclusion that \"Someone who passed the exam had not read the book\"   Let   be \"  is in the class\"  Let   be \"  passed the exam\"  Let   be \"  has read the book\"",
            "title": "Rules of Inference for Quantified Statements"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#sets-functions-relations-sequences-and-sums",
            "text": "",
            "title": "Sets, Functions, Relations, Sequences and Sums"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set",
            "text": "Set  An unordered collection of elements",
            "title": "Set"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set-operations",
            "text": "Name  Example      Equality     Membership     Non-Membership     Empty Set     Union     Intersection     Diffrence     Complement     Subset     Superset     Power Set   (set of all subsets)    Cardinality     Cartesian Product",
            "title": "Set Operations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#common-sets",
            "text": "Name  Symbol  Description      Booleans      Natural numbers      Integer      Positive Integers      Real Numbers      Rational      Complex Numbers",
            "title": "Common Sets"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#set-identitys",
            "text": "",
            "title": "Set Identitys"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#syntax",
            "text": "Function  A function   from set   to set   assigns an element from   to  , this is written as  .   Examples:   Ceil -   Floor -   Identity -   Factorial -       Type of function  Condition  Examples      Injective   ,     Surjective   ,     Bijection  Injective and surjective  ,",
            "title": "Syntax"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#composition",
            "text": "Let   and  . The composition function   is    The composition of two functions is a function  The composition of two injective functions is a injective function  The composition of two surjective functions is a surjective function  The composition of two bijections is a bijection",
            "title": "Composition"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#inverse",
            "text": "If   is a bijection, then the inverse of  , written   is   iff    Inverse of the identity function, is the identity function  Inverse of   is      and   is the identity function",
            "title": "Inverse"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#relations",
            "text": "A binary relation   on sets   and   is a subset    Often written as   for   A function   is a restricted relation where   For all a in   their exsists a   in   where (a, b) in relation   and   is unique      Given sets   a subset   is an  -ary relation.    where   is students and   is courses,",
            "title": "Relations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#relation-composition",
            "text": "Let   and  . The composition relation   is   The expression specifys the relations where   and   have a common  , thus   Closure   is a relation on  :    is the identity relation",
            "title": "Relation composition"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#types-of-relation",
            "text": "Type of relation  Condition  Example      Reflexive   ,     Symetric      Antisymetric   ,  ,     Transitive   ,  ,     Equivalance  Reflexive, symetric and transitive",
            "title": "Types of relation"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#equivalance-classes",
            "text": "Let   be an equivalence realtion on a set   and   let   be the equivalance class of a w.r.t  .  If   the   is called a representative of the equivalance class.  Let   be an equivalance realtion on   amd  . Then following statements are equivalnet",
            "title": "Equivalance classes"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#partitions-of-a-set",
            "text": "A partition of set   is a collection of disjoint, nonempty subsets that have   as their union, in other words the collection of subsets   with   (where   is the index set) forms a partition of   iff    for all    for all     From this can see:   If   is an equivalance class on  , then the equivalance classes of   form a partion of  .  Conversly, given a partition   of  , there exsists an equivalance relation   that has the sets  ,  , as its equivalence classes.",
            "title": "Partitions of a Set"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#sequences",
            "text": "Sequence  Ordered list of elements for example,   is   defines the sequence   Geometric progressions  A sequence in the form   Arithmetic progressions  A sequence in the form",
            "title": "Sequences"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#recurrence-relations",
            "text": "Recurrence relations  A recurance relations for   is an equation that expreses   in terms of one or more elements of     After 1 month a pair of rabbits is placed on an island  After every 2 months, each pair of rabbits produces a new pait of rabbits    The realtion is:  Solving a recurrence relations if finding the nth term, one way of solving is an iterative aproach   Supose a person deposits $1000 in savings with 3 percent intrest, how much is the account worth after 20 years   Let   denote the amount after   years",
            "title": "Recurrence relations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#sumations",
            "text": "Given a sequence  , the sum of the terms is",
            "title": "Sumations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#usefull-sumations",
            "text": "Sum  Closed form       ,",
            "title": "Usefull sumations"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#product",
            "text": "Given a sequence  , the product of the terms is   or more generally for a finite index set  ,",
            "title": "Product"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#cartinality",
            "text": "Finite set  A set   is finite with cardinality   if there is a bijection from the set   to  .  Infinite set  A set that is not finite    Prove the set of natural numbers,  , is an infinite set.   Consider the function   defined as    is injective, since every element in the domain has an element in the codomain which is mapped to it.   is not subjective, since   is in the codomain but is has no element in the domain which maps to it.  Thus   is not a bijection.  Thus   is an infinite set.",
            "title": "Cartinality"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#countable-sets",
            "text": "Countable  A set that is either finite or has the same cardinality as the set of the positive integers  Uncountable  A set that is not countable   An infinite set   is countable, we denote the cardinality of   by      If   and   are countable sets, then   is also countable  If   is countable and for each   the set   is countable then   is countable    Show that the set of real numbers is uncountable    Assume that the set of real numbers is countable  The the real numbers between   and   must also be countable  We can list these numbers with decimal noation   Where   We can define a number   Where   So   defines a number that is diffrent from   in the   number  Thus their is a real number between   and   that is not in the list  Therefore the set of real numbers cannot be listed.",
            "title": "Countable sets"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#schroder-bernstein-theorem",
            "text": "If   and   are sets with   and  , then  . In other words, if there are one-to-one functions   from   to   and   from   to  , then there is a one-to-one correspondence between   and  .   Show that    Since  , their is a one-to-one function from   to   Lets define  , which is a mapping from   to  ,   so their is a one   to  .  Thus  , due to Schr\u00f6der-Bernstein Theorem",
            "title": "Schr\u00f6der-Bernstein Theorem"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#cantors-theorem",
            "text": "Proof   Consider the injection   with   for any  .  Therefore   Assume a surjection   exsists  Let   Since   is a surjection, there must exist an   such that   If   then by definition of  ,   (contradiction)  If   then  , by definition of  ,   (contradiction)      One consequence of cantors theorem is that their is an infinite hierarchy of sets of larger cardinality.",
            "title": "Cantor\u2019s theorem"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#induction",
            "text": "Mathematical Induction  To prove   is true for all positive integers, where   is a propositional function  Basic Step  Verifying   is true  Inductive step  Showing that the conditional   is true for all positive integers     Prove that if   is a positive integer    , thus   Assuming   holds, then it must be shown that   holds   Thus if we can show  , then",
            "title": "Induction"
        },
        {
            "location": "/Discrete-Mathmatics-and-Mathmatical-Reasoning/#strong-induction",
            "text": "Mathematical Strong Induction  To prove   is true for all positive integers, where   is a propositional function  Basic Step  Verifying   is true  Inductive step  Showing that the conditional   is true for all positive integers     Prove that if  , then   can be written as the product of primes    is true since   (  is a prime itself).   is either a prime or a composite number  If it is prime, then itself is a product of primes  If it is composite, then   is the product of two positive integers   and   that are  .  Thus since both are less than  , by strong induction they can be rewritten as the product of primes  Thus   can be written as the product of primes",
            "title": "Strong induction"
        },
        {
            "location": "/Introduction-to-Computer-Systems/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nFloating point\n\n\n\n\nMantissa/significand\n\n\nFractional part\n\n\nExponent\n\n\nPower of $2$\n\n\n\n\n\n\nConvert $25_{10}$ in floating point form\n\n\n$25_{10} = 011001_2$\n\n\n$1.1001 \\times 2^4$\n\n\n\n\nWhy normalize?\n\n\n\n\nSimplifiys machine representation\n\n\nSimplifys comparisons e.g. $0.00000101$ vs $0.000001$\n\n\nMore compact for small/large numbers\n\n\n\n\nIEEE 654 Floating Point Standard\n\n\n\n\n1'st bit is sign bit ($s$)\n\n\n8 bits for exponent ($exp$)\n\n\nrest for mantissa ($m$)\n\n\n\n\nEncoding:\n$s \\times m \\times 2 ^ {exp - 127}$\n\n\n(127 is the \nbias\n)\n\n\n$0.75_{10} = 0.11_2 = {(1.1 \\times 2^{-1})}_2$\n\n\nWhy bias?\n\n\n\n\nExponent can always be positive (no need to store sign bit)\n\n\nSimplifys comparison operations\n\n\n\n\nSpecial values\n\n\n\n\n\n\n\n\nExponenent\n\n\nMantisa\n\n\nNumber\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\n1-254\n\n\nAnything\n\n\nFloating point number\n\n\n\n\n\n\n255\n\n\n0\n\n\nInfinity (signed)\n\n\n\n\n\n\n255\n\n\nnon-zero\n\n\nNaN (not a number)\n\n\n\n\n\n\n\n\nMIPS\n\n\n\n\nISA\n\n\nInstruction set architecture - The interface between the hardware and the software\n\n\nMIPS\n\n\nA real world ISA used by many diffrent processors since the 80s\n\n\n\n\nInstruction set\n\n\n\n\nAssemble Language\n\n\nSymbolic representation of machine instructions.\n\n\n\n\nMachine code are instructions stored as binary values, assembly language is a one-to-one mapping that allow human programmers to reason about programs.\n\n\nHigh level:\n\n\na[0] = b[0] + 10\n\n\n\n\nMIPS:\n\n\nlw r4, 0(r2)    # Load word - Get the value fo b[0] from memory and store in r4\nadd r5,r4,10    # Add - Compute b[0]+10 and store in r5\nsw r5,0(r1)     # Save word - Store r5 into a[0]\n\n\n\n\nMIPS does not allow accessing and operating on data at the same time\n\n\nArithmatic and Logical Operations\n\n\n\n\nadd a, b, c\n \n\n\nsub a, b, c\n \n\n\nsll a, b, c\n \n\n\nsrl a, b, c\n \n (logical)\n\n\nsra a, b, c\n \n (arithmatic)\n\n\n\n\nRegisters\n\n\n\n\nRegister\n\n\nStorage locations inside the processor that holds program variables and control state\n\n\n\n\n\n\nSome registers are special purpose\n\n\nRegister \n$zero\n is always zero for example\n\n\n$pc\n is the program counter, the adress of the next instruction\n\n\n$ra\n stores the return adress to return to after executing a method\n\n\n\n\n\n\nMost are for general use\n\n\n$s0-$s7\n are variables\n\n\n$t0-$t9\n are tempory variables\n\n\n\n\n\n\n\n\nEndinness\n\n\n\n\nEndinness\n\n\nThe sequential order in which bytes are arranged in memory\n\n\nBig-endian\n\n\nBytes orders by most significant bit\n\n\nLittle-endian\n\n\nBytes ordered by least significant bit\n\n\n\n\nMIPS instruction format\n\n\nEach assembly instruction translates into 1 machine instruction. Their are 3 formts of instructions\n\n\n\n\n\n\nR-format (e.g. \nadd\n, \nsub\n, \nand\n, \nor\n ...) \n\n\n\n\n\n\nI-format (e.g. \naddi\n, \nlw\n, \nsw\n, ...) \n\n\n\n\n\n\nJ-format (\nj\n) \n\n\n\n\n\n\nMIPS examples\n\n\nSwap\n\n\nThis function swaps two consecutive array elements \n\n\n# Compute the adress of the array\nsll $t0, $a1 2      # reg $t0 = idx * 4\nadd $t0, $a0, $t0   # reg $t0 = v + (idx * 4)\n                    # $t0 holds the address of array[idx]\n\n# Load the two values to be swapped\nlw $t1, 0($t0)      # reg $t0 = array[idx]\nlw $t1, 4($t0)      # reg $t0 = array[idx + 1]\n\n# Store the swapped values back in memory\nsw $t2, 0($t0)      # array[idx] = $t2\nsw $t1, 4($t0)      # array[idx+1] = $t0\n\n\n\n\nIf\n\n\nbeq $s1,$s2,label2      # if(s1 == s2) jump to label2\nstmnt1                  # else\nj label3 # skip stmnt2  # continue from label3\nlabel2: stmnt2          # body of if\nlabel3: stmnt3          # continue from if\n\n\n\n\nLoop\n\n\nloop:\n    beq $s1,$zero,end               # $s1 holds count\n    ...                             # Body of loop                           \n    j loop                          # Jump back to start\nend:\n    ...\n\n\n\n\nMethod calls\n\n\nTo jump into a method use \njal label\n (jump and link) which:\n\n\n\n\nSets \n$ra\n to \n$pc + 4\n (the next instruction)\n\n\nSets \n$pc\n to the adress of the label\n\n\n\n\nWhen returning user \njr $ra\n (jump register) which:\n\n\n\n\nSets \n$pc\n to the value of \n$ra\n, the adress we want to return to\n\n\n\n\nConvention\n\n\nIt is convention to use registers in a certain way\n\n\n\n\n$a0\n - \n$a4\n as method parameters\n\n\n$r1\n and \n$r2\n as return values\n\n\n$s0\n - \n$s7\n are preserved across call boundrys\n\n\n$t0\n - \n$t9\n are \nnot\n preserved across call boundrys\n\n\n\n\nNested calls\n\n\nIf we have a nested call, we can store the return adress onto the stack allowing us to nest \"infinitly\" (or until the machine runs out of stack space)\n\n\nTo push a word:\n\n\n\n\nMove the stack pointer down with \naddi $sp, $sp, -4\n\n\nSave the return adress onto the stack \nsw $ra 0($sp)\n\n\n\n\nTo pop a word:\n\n\n\n\nFetch return adress from the stack \nlw $ra, 0($sp)\n\n\nMove stack pointer up with \naddi $sp, $sp 4\n\n\n\n\nThe stack is also used to:\n\n\n\n\nSave \n$s\n registers\n\n\nPass and return values if their isnt enough registers\n\n\nLocal variables inside a function (that dont fit into registers)",
            "title": "Introduction to Computer Systems"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#floating-point",
            "text": "Mantissa/significand  Fractional part  Exponent  Power of $2$    Convert $25_{10}$ in floating point form  $25_{10} = 011001_2$  $1.1001 \\times 2^4$",
            "title": "Floating point"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#why-normalize",
            "text": "Simplifiys machine representation  Simplifys comparisons e.g. $0.00000101$ vs $0.000001$  More compact for small/large numbers",
            "title": "Why normalize?"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#ieee-654-floating-point-standard",
            "text": "1'st bit is sign bit ($s$)  8 bits for exponent ($exp$)  rest for mantissa ($m$)   Encoding:\n$s \\times m \\times 2 ^ {exp - 127}$  (127 is the  bias )  $0.75_{10} = 0.11_2 = {(1.1 \\times 2^{-1})}_2$",
            "title": "IEEE 654 Floating Point Standard"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#why-bias",
            "text": "Exponent can always be positive (no need to store sign bit)  Simplifys comparison operations",
            "title": "Why bias?"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#special-values",
            "text": "Exponenent  Mantisa  Number      0  0  0    1-254  Anything  Floating point number    255  0  Infinity (signed)    255  non-zero  NaN (not a number)",
            "title": "Special values"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#mips",
            "text": "ISA  Instruction set architecture - The interface between the hardware and the software  MIPS  A real world ISA used by many diffrent processors since the 80s",
            "title": "MIPS"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#instruction-set",
            "text": "Assemble Language  Symbolic representation of machine instructions.   Machine code are instructions stored as binary values, assembly language is a one-to-one mapping that allow human programmers to reason about programs.  High level:  a[0] = b[0] + 10  MIPS:  lw r4, 0(r2)    # Load word - Get the value fo b[0] from memory and store in r4\nadd r5,r4,10    # Add - Compute b[0]+10 and store in r5\nsw r5,0(r1)     # Save word - Store r5 into a[0]  MIPS does not allow accessing and operating on data at the same time",
            "title": "Instruction set"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#arithmatic-and-logical-operations",
            "text": "add a, b, c    sub a, b, c    sll a, b, c    srl a, b, c    (logical)  sra a, b, c    (arithmatic)",
            "title": "Arithmatic and Logical Operations"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#registers",
            "text": "Register  Storage locations inside the processor that holds program variables and control state    Some registers are special purpose  Register  $zero  is always zero for example  $pc  is the program counter, the adress of the next instruction  $ra  stores the return adress to return to after executing a method    Most are for general use  $s0-$s7  are variables  $t0-$t9  are tempory variables",
            "title": "Registers"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#endinness",
            "text": "Endinness  The sequential order in which bytes are arranged in memory  Big-endian  Bytes orders by most significant bit  Little-endian  Bytes ordered by least significant bit",
            "title": "Endinness"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#mips-instruction-format",
            "text": "Each assembly instruction translates into 1 machine instruction. Their are 3 formts of instructions    R-format (e.g.  add ,  sub ,  and ,  or  ...)     I-format (e.g.  addi ,  lw ,  sw , ...)     J-format ( j )",
            "title": "MIPS instruction format"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#mips-examples",
            "text": "",
            "title": "MIPS examples"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#swap",
            "text": "This function swaps two consecutive array elements   # Compute the adress of the array\nsll $t0, $a1 2      # reg $t0 = idx * 4\nadd $t0, $a0, $t0   # reg $t0 = v + (idx * 4)\n                    # $t0 holds the address of array[idx]\n\n# Load the two values to be swapped\nlw $t1, 0($t0)      # reg $t0 = array[idx]\nlw $t1, 4($t0)      # reg $t0 = array[idx + 1]\n\n# Store the swapped values back in memory\nsw $t2, 0($t0)      # array[idx] = $t2\nsw $t1, 4($t0)      # array[idx+1] = $t0",
            "title": "Swap"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#if",
            "text": "beq $s1,$s2,label2      # if(s1 == s2) jump to label2\nstmnt1                  # else\nj label3 # skip stmnt2  # continue from label3\nlabel2: stmnt2          # body of if\nlabel3: stmnt3          # continue from if",
            "title": "If"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#loop",
            "text": "loop:\n    beq $s1,$zero,end               # $s1 holds count\n    ...                             # Body of loop                           \n    j loop                          # Jump back to start\nend:\n    ...",
            "title": "Loop"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#method-calls",
            "text": "To jump into a method use  jal label  (jump and link) which:   Sets  $ra  to  $pc + 4  (the next instruction)  Sets  $pc  to the adress of the label   When returning user  jr $ra  (jump register) which:   Sets  $pc  to the value of  $ra , the adress we want to return to",
            "title": "Method calls"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#convention",
            "text": "It is convention to use registers in a certain way   $a0  -  $a4  as method parameters  $r1  and  $r2  as return values  $s0  -  $s7  are preserved across call boundrys  $t0  -  $t9  are  not  preserved across call boundrys",
            "title": "Convention"
        },
        {
            "location": "/Introduction-to-Computer-Systems/#nested-calls",
            "text": "If we have a nested call, we can store the return adress onto the stack allowing us to nest \"infinitly\" (or until the machine runs out of stack space)  To push a word:   Move the stack pointer down with  addi $sp, $sp, -4  Save the return adress onto the stack  sw $ra 0($sp)   To pop a word:   Fetch return adress from the stack  lw $ra, 0($sp)  Move stack pointer up with  addi $sp, $sp 4   The stack is also used to:   Save  $s  registers  Pass and return values if their isnt enough registers  Local variables inside a function (that dont fit into registers)",
            "title": "Nested calls"
        },
        {
            "location": "/Introduction-to-Software-Engineering/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nUse Cases\n\n\n\n\nUse case\n\n\nA task involving the system which has value for one or more stakeholders.\n\n\nActors\n\n\nA stakeholder who takes an active part in the use case.\n\n\nPrimary Actor\n\n\nStakeholder with primary intrest in use case (usually the one triggering the use case).\n\n\nSupporting actors\n\n\nActors also envolved\n\n\n\n\nSome stakeholders may not be participating in a use case (so neither primary or supporting actors).\n\n\nActors can be:\n\n\n\n\nUsers of a system\n\n\nAn external system, which interacts with the system\n\n\n\n\nUsually a use case is a sequence of steps, however they may other paths, they may succeed, fail, or succeed in an alternate way.\n\n\nExample\n\n\nMain success scenario\n\n\n1. Customer selects item\n2. Customer checks out\n3. ...\n4. Email confirmation\n\n\n\n\nExtensions - variations of the main success scenario\n\n\n6a. Credit card auth fails\n    .1 Re-enter details\n\n\n\n\nUse case templates\n\n\n\n\nGoal:\n What the primary actor wishes to acheive\n\n\nSummary:\n Description of use case\n\n\nStakeholders and each\u2019s Interest in the use case\n\n\nPrimary actor\n\n\nSupporting actors\n\n\nTrigger:\n The event that leads to this use case being performed.\n\n\nPre-conditions/Assumptions:\n What can be assumed to be true when the use case starts\n\n\nGuarantees:\n What the use case ensures at its end\n\n\nSuccess guarantees\n\n\nFailure guarantees\n\n\nMinimal guarantees\n\n\n\n\n\n\nMain Success Scenario\n\n\nAlternative scenarios\n\n\n\n\nA use case can:\n- Diffrent levels of detail\n    - Depending on part of development process\n- May refer to other use cases\n- Descripe diffrent scopes\n\n\nRequirements capture\n\n\n\n\nIdentify actors\n\n\nFor each actor\n\n\nWhat do they need\n\n\nAny other expected interactions\n\n\nWhich use cases have priority\n\n\n\n\n\n\n\n\nUse cases are often functional requirements, with non-functional requirements attached. Other times. Non-functional requirements apply to subsets or all of use-cases.\n\n\nOther uses\n\n\n\n\nDrive design\n\n\nDesign validation\n\n\nDoes the design work\n\n\n\n\n\n\nTesting\n\n\nGood source for system tests\n\n\n\n\n\n\n\n\nProblems\n\n\n\n\nMay be to much detail (constraining design)\n\n\nSupporting actors may not be strictly necessary i.e. librarian may not be involved in borrowing a book (in a modern library)\n\n\nLess attension to architecture and static object structure.\n\n\nMay miss requirements not associated with actors.\n\n\n\n\nDesign\n\n\n\n\nDesign\n\n\nHow softawre will meet the requirements\n\n\n\n\nOutputs of design:\n\n\n\n\nModels\n\n\nUML / SImulink\n\n\nOften graphical\n\n\nCan be executable\n\n\n\n\n\n\nWritten documents\n\n\nRecord reasons for decisions (\n\n\ntrace back when problem occors to relevent stakeholder\n\n\n\n\n\n\n\n\nCriteria:\n\n\n\n\nThe design can meet the requirements\n\n\nIs it maintainable?\n\n\nCan it be explained to implementors\n\n\nFits constraints of exsisting technology (legacy components)\n\n\nMakes future design choices easy\n\n\n\n\n\n\nHigh level (architectural) design\n\n\nHow subsytems are split up\n\n\nLow level (detailed) design\n\n\nHow subsystems are composed\n\n\n\n\nAt each level:\n\n\n\n\nWhat are the responsibilities of each component?\n\n\nwhat are the interfaces?\n\n\nWhat are the messages exchanged (what protocols)?\n\n\n\n\n\n\nArchitecture\n\n\nThe way that components work together.\n\n\n\n\n\n\n\n\nWhat are the components\n\n\n\n\nWhere shall we put the encapsulation barriers?\n\n\nWhich decisions do we want to hide inside components (so they can be changed without effecting the rest of the system)?\n\n\n\n\n\n\n\n\nWhat are the connectors?\n\n\n\n\nHow/what do the components need to communicate?\n\n\nWhat should be the interfaces?\n\n\nWhat protocols should be used?\n\n\n\n\n\n\n\n\nMore architecutral decisions:\n\n\n\n\nWhat language and/or component standard is going to be used?\n\n\nIs their an appropriate exising framework?\n\n\nWhat conventions for error handling?\n\n\nbackups\n\n\nresiliance\n\n\nfail gracefully\n\n\n\n\n\n\n\n\nDetailed design\n\n\n\n\nArchitecture has be designed\n\n\nEach person/team is in charge of designing one subsystem\n\n\nWhat external interfaces must it work with?\n\n\nWhat classes and behaviour are needed?\n\n\nCoordination with system architect to change interface if required.\n\n\n\n\nPrinciples\n\n\n\n\nCohesion\n\n\nA mesure of the strenth o fthe realationship between the pieces of functionality within the component. High cohesion has increased understandability, maintainability and reliability.\n\n\nCoupling\n\n\nA mesure of the strength of the inter-connection between components. Loose coupling increases understandability and maintainablilty.\n\n\nAbstraction\n\n\nA view of some entity that focuses on the infomation relevent to a particular purpose.\n\n\nEncapsulation\n\n\nGrouping and packaging the elements and internal details of an abstraction and making those details inaccessible.\n\n\nSeperation of interface/implementation\n\n\nSpecifing a public interface, known to the clients, separate from the details of how the component is realized.\n\n\nDecomposition\n\n\nDivinding large systems into smaller components with distinct responsibilitys.\n\n\n\n\nModeling\n\n\n\n\nModel\n\n\nA precise represntation of some of the information needed to solve a problem using a computer.\n\n\n\n\nA UML model\n- represented by set of diagrams\n- structured represnetation too (XML)\n- must obey rules of UML standard\n- (fairly) precise meaning\n- Used informally (talking around whiteboard)\n\n\nBig design up front\n\n\n\n\nOften unavoidable\n\n\nIf done right, simplifys developent\n\n\nError prone (changing requirements)\n\n\nWastefull (mistakes in requirements)\n\n\n\n\nXP maxinms:\n- You aint going to need it\n- Do the simplest thing that could possibly work",
            "title": "Introduction to Software Engineering"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#use-cases",
            "text": "Use case  A task involving the system which has value for one or more stakeholders.  Actors  A stakeholder who takes an active part in the use case.  Primary Actor  Stakeholder with primary intrest in use case (usually the one triggering the use case).  Supporting actors  Actors also envolved   Some stakeholders may not be participating in a use case (so neither primary or supporting actors).  Actors can be:   Users of a system  An external system, which interacts with the system   Usually a use case is a sequence of steps, however they may other paths, they may succeed, fail, or succeed in an alternate way.",
            "title": "Use Cases"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#example",
            "text": "Main success scenario  1. Customer selects item\n2. Customer checks out\n3. ...\n4. Email confirmation  Extensions - variations of the main success scenario  6a. Credit card auth fails\n    .1 Re-enter details",
            "title": "Example"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#use-case-templates",
            "text": "Goal:  What the primary actor wishes to acheive  Summary:  Description of use case  Stakeholders and each\u2019s Interest in the use case  Primary actor  Supporting actors  Trigger:  The event that leads to this use case being performed.  Pre-conditions/Assumptions:  What can be assumed to be true when the use case starts  Guarantees:  What the use case ensures at its end  Success guarantees  Failure guarantees  Minimal guarantees    Main Success Scenario  Alternative scenarios   A use case can:\n- Diffrent levels of detail\n    - Depending on part of development process\n- May refer to other use cases\n- Descripe diffrent scopes",
            "title": "Use case templates"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#requirements-capture",
            "text": "Identify actors  For each actor  What do they need  Any other expected interactions  Which use cases have priority     Use cases are often functional requirements, with non-functional requirements attached. Other times. Non-functional requirements apply to subsets or all of use-cases.",
            "title": "Requirements capture"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#other-uses",
            "text": "Drive design  Design validation  Does the design work    Testing  Good source for system tests",
            "title": "Other uses"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#problems",
            "text": "May be to much detail (constraining design)  Supporting actors may not be strictly necessary i.e. librarian may not be involved in borrowing a book (in a modern library)  Less attension to architecture and static object structure.  May miss requirements not associated with actors.",
            "title": "Problems"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#design",
            "text": "Design  How softawre will meet the requirements   Outputs of design:   Models  UML / SImulink  Often graphical  Can be executable    Written documents  Record reasons for decisions (  trace back when problem occors to relevent stakeholder     Criteria:   The design can meet the requirements  Is it maintainable?  Can it be explained to implementors  Fits constraints of exsisting technology (legacy components)  Makes future design choices easy    High level (architectural) design  How subsytems are split up  Low level (detailed) design  How subsystems are composed   At each level:   What are the responsibilities of each component?  what are the interfaces?  What are the messages exchanged (what protocols)?    Architecture  The way that components work together.     What are the components   Where shall we put the encapsulation barriers?  Which decisions do we want to hide inside components (so they can be changed without effecting the rest of the system)?     What are the connectors?   How/what do the components need to communicate?  What should be the interfaces?  What protocols should be used?",
            "title": "Design"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#more-architecutral-decisions",
            "text": "What language and/or component standard is going to be used?  Is their an appropriate exising framework?  What conventions for error handling?  backups  resiliance  fail gracefully",
            "title": "More architecutral decisions:"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#detailed-design",
            "text": "Architecture has be designed  Each person/team is in charge of designing one subsystem  What external interfaces must it work with?  What classes and behaviour are needed?  Coordination with system architect to change interface if required.",
            "title": "Detailed design"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#principles",
            "text": "Cohesion  A mesure of the strenth o fthe realationship between the pieces of functionality within the component. High cohesion has increased understandability, maintainability and reliability.  Coupling  A mesure of the strength of the inter-connection between components. Loose coupling increases understandability and maintainablilty.  Abstraction  A view of some entity that focuses on the infomation relevent to a particular purpose.  Encapsulation  Grouping and packaging the elements and internal details of an abstraction and making those details inaccessible.  Seperation of interface/implementation  Specifing a public interface, known to the clients, separate from the details of how the component is realized.  Decomposition  Divinding large systems into smaller components with distinct responsibilitys.",
            "title": "Principles"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#modeling",
            "text": "Model  A precise represntation of some of the information needed to solve a problem using a computer.   A UML model\n- represented by set of diagrams\n- structured represnetation too (XML)\n- must obey rules of UML standard\n- (fairly) precise meaning\n- Used informally (talking around whiteboard)",
            "title": "Modeling"
        },
        {
            "location": "/Introduction-to-Software-Engineering/#big-design-up-front",
            "text": "Often unavoidable  If done right, simplifys developent  Error prone (changing requirements)  Wastefull (mistakes in requirements)   XP maxinms:\n- You aint going to need it\n- Do the simplest thing that could possibly work",
            "title": "Big design up front"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/",
            "text": ".latex-box.math-false {text-align: center;}\n.math-true {vertical-align: middle;}\n\n\n\nClosure Properties of Regular Languages\n\n\n-NFA\n\n\nIf we allow \n transitions, which represents an instananious transition, NFA's can be transformed to have one start and one accepting state.\n\n\nThis doesnt increase the power of NFA's, but it has some convenience.\n\n\nConcatination\n\n\n\n\n is the concatination of two languages, for example \n, \n becomes \n\n\nIts obvious the concatination is closed, since we can add an \n transition between the start and accepting states of the machines for languages \n and \n\ns\n\n\nKleene star\n\n\n\n\n Is the langauge of 0 or more strings of \n\n\nAgain kleene start is also closed. By introducing a new start state (which is also an accepting state) with an \n transition to the machine for \n and add \n transitions back from the machine to the new start/accepting state. This allows the machine for \n to run for any amount of times.\n\n\nRegular Expressions\n\n\nRegular expressions are a language for defining languages.\n\n\n\n\n\n\n\n\nSymbol\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n (for \n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder\n\n\nIn the absence of brackets the order of operation is as follows:\n\n\n\n\n\n\n\n\n\n\n\n\nKleene's Theorem\n\n\nKleene's Theorem:\n DFA's and regular expressions give rise to exactly the same class of langauges (the regular langauges)\n\n\nSo regular languages can be defined as regular expressions.\n\n\nKleene algebra\n\n\nRegular expressions can be manipulated with kleene algebra without changing the language\n\n\n\n\n\n\n\n\n...\n\n\n\n\n\n\nArdens rule\n\n\nGiven an equation of the form \n its smallest solution is \n. If \n, this is the only solution\n\n\nDFA's to regular expressions\n\n\nFor each state \n, the variable \n stands for the set of states that take us from \n to the accepting state.\n\n\n\n\nApplications of regular languages\n\n\nGrep\n\n\nSearch for prices in pounds and pence:\n\n\ngrep \"[0-9]*\\.[0-9][0-9]\" document.txt\n\n\n\n\n\n\nfgrep\n searches for one or more fixed string, using an efficent string matching algorthum\n\n\ngrep\n searches for strings matching a pattern\n\n\negrep\n searches for strings matching an extended pattern\n\n\n\n\nString searching\n\n\nSupose we want to search for string \n in document \n. An efficent implentation is the Knuth-Morris-Pratt algorithum:\n\n\n\n\nConvert NFA accepting \n     to DFA M (costs some time, worth it for short \n and long \n).\n\n\nRun \n through \n (each character in \n processed once, no buffering).\n\n\nEvery time we get to the accepting state of \n, signal a hit.\n\n\n\n\nThis can be extended to search for mulitple strings in parralel with a more complex NFA.\n\n\nPattern searching\n\n\negrep\n will print all lines containing a match.\n\n\n\n\nWe can convert a pattern into a (smallish) NFA.\n\n\nWe can run the NFA using the just-in-time simulation (avoids exponential state-space blow-up).\n\n\n\n\nData validation\n\n\n\n\nWithin XML we can enforce constraints on parts of the data.\n\n\nFor text fields on web froms, we can check if the input text is in the correct form.\n\n\n\n\nLexing\n\n\nEven tough a higher level language is to complex to be regular, regular expressions can be used to identify the fundemental building blocks (tokens) of the language.\n\n\n\n\nLexical Analysis\n\n\nBreaking up source code into a series of tagged tokens (lexemes)\n\n\nLexical class\n\n\nThe class of a token, for example \n1000\n would be an integer literal, \nfoobar\n would be an identifier.\n\n\n\n\nHow lexers work\n\n\n\n\nBuild NFA's for the lexical classes \n (in order of priority)\n\n\nRun the 'parrallel' automaton \n until it expires\n\n\nThe last point in which we were in an accepting state is the largest match, chose the smallest \n such that were in an accepting state of \n. Chose class \n as the lexical class for \n which is the highest priorty.\n\n\nPerform the specified action for the class \n\n\n\n\nVerification\n\n\nRegulare langauge theory can help verify desirable properites:\n\n\n\n\nSaftey, i.e. \nbad things dont happen\n\n\nLiveness, i.e. \ngood things do happen\n\n\nFierness, i.e. \nthings good for some processes dont cause to much badness to others\n\n\n\n\nExample\n\n\nSuppose we have two processes \n that have use of a shared resource, but must not be given access at the same time.\n\n\n can comunicate using three shared flags\n- \nreq0\n initially false, whether \n wants access\n- \nreq1\n initially false, whether \n wants access\n- \nturn\n who is being allowed a turn\n\n\nCode for \n when it wants access\n\n\nreq0 = true\nturn = 1\nwhile(req1 && turn == 1) WAIT\n// P0 can now access resource\nreq0 = false\n\n\n\n\nCode for \n is the same with \n swapped and \nreq0\n and \nreq1\nswapped.\n\n\nThis can be moddled by a finite state machine:\n\n\nThe language for the complete system can now be obtained:\n\n\nwhere \n is the interleaving of regular langauges.\n\n\nNow machine \n with 200 states can be built.\n\n\nNow we can verify\n- Mutual exclusion: \n and \n can never access simulaneously.\n- Progress\n\n\nThe Pumping Lemma\n\n\nLoops in DFA's\n\n\nA machine \n with states \n will always have a loop since we can process strings \n where \n, thus we visit some state twice. Thus any string \n can be decomposed into:\n- \n, the prefix of \n that leads to the first visit of the repeated state \n\n- \n, the loop which goes from \n to \n\n- \n, whatever is left of \n after \n\n\nLemma\n\n\nSuppose \n is a regular language, then \n has the following property \n:\n\n\nTheir exists \n such that, for all strings \n with \n and \n, there exist strings \n such that \n, \n, and for every \n we have \n \n\n\nContrapositive\n\n\nTo prove a language is not reqular, we take the contrapositive of the pumping lemma \n:\n\n\nFor all \n, there exist strings \n with \n and \n such that, for every decomposition of \n as \n where \n, their is some \n which \n\n\nUsing the pumping lemma\n\n\n\n\nYour argument must work for all \n.\n\n\nChoose strings \n (which might depend on \n) to satisfy \n and \n. Additionaly \n should \"disallow pumping\" (number of loops depend on language).\n\n\nYour argument must work for all decompositions of \n as \n with \n.\n\n\nChoose the number \n such that \n, here \n might depend on all the previous data.\n\n\n\n\nExample 1\n\n\n\n\nShow that \n is not regular\n\n\n\n\nSuppose \n\n\nLet \n, \n, \n\n\nLet \n\n\n for some \n\n\nThus \n\n\n, thus \n satisfys \n, thus it is not regular\n\n\n\n\n\n\nExample 2\n\n\n\n\nShow that \n is not regular\n\n\n\n\nSuppose \n\n\nLet \n, \n, \n so \n\n\nGiven \n where \n, \n (since \n is non empry and the length of \n is length \n)\n\n\nLet \n, thus \n, \n\n\nThe length of the new string becomes \n\n\nThe next perfect string after \n is \nk^2 + 2k + 1\nk^2\n(k+1)^2 = \n\n\nThus \n isnt a perfect square, thus \n\n\nThus \n satisfys \n, thus it is not regular",
            "title": "Processing Formal and Natural Languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#closure-properties-of-regular-languages",
            "text": "",
            "title": "Closure Properties of Regular Languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#-nfa",
            "text": "If we allow   transitions, which represents an instananious transition, NFA's can be transformed to have one start and one accepting state.  This doesnt increase the power of NFA's, but it has some convenience.",
            "title": "-NFA"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#concatination",
            "text": "is the concatination of two languages, for example  ,   becomes   Its obvious the concatination is closed, since we can add an   transition between the start and accepting states of the machines for languages   and  \ns",
            "title": "Concatination"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleene-star",
            "text": "Is the langauge of 0 or more strings of   Again kleene start is also closed. By introducing a new start state (which is also an accepting state) with an   transition to the machine for   and add   transitions back from the machine to the new start/accepting state. This allows the machine for   to run for any amount of times.",
            "title": "Kleene star"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#regular-expressions",
            "text": "Regular expressions are a language for defining languages.     Symbol  Definition               (for  )",
            "title": "Regular Expressions"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#order",
            "text": "In the absence of brackets the order of operation is as follows:",
            "title": "Order"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleenes-theorem",
            "text": "Kleene's Theorem:  DFA's and regular expressions give rise to exactly the same class of langauges (the regular langauges)  So regular languages can be defined as regular expressions.",
            "title": "Kleene's Theorem"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#kleene-algebra",
            "text": "Regular expressions can be manipulated with kleene algebra without changing the language     ...",
            "title": "Kleene algebra"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#ardens-rule",
            "text": "Given an equation of the form   its smallest solution is  . If  , this is the only solution",
            "title": "Ardens rule"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#dfas-to-regular-expressions",
            "text": "For each state  , the variable   stands for the set of states that take us from   to the accepting state.",
            "title": "DFA's to regular expressions"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#applications-of-regular-languages",
            "text": "",
            "title": "Applications of regular languages"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#grep",
            "text": "Search for prices in pounds and pence:  grep \"[0-9]*\\.[0-9][0-9]\" document.txt   fgrep  searches for one or more fixed string, using an efficent string matching algorthum  grep  searches for strings matching a pattern  egrep  searches for strings matching an extended pattern",
            "title": "Grep"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#string-searching",
            "text": "Supose we want to search for string   in document  . An efficent implentation is the Knuth-Morris-Pratt algorithum:   Convert NFA accepting       to DFA M (costs some time, worth it for short   and long  ).  Run   through   (each character in   processed once, no buffering).  Every time we get to the accepting state of  , signal a hit.   This can be extended to search for mulitple strings in parralel with a more complex NFA.",
            "title": "String searching"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#pattern-searching",
            "text": "egrep  will print all lines containing a match.   We can convert a pattern into a (smallish) NFA.  We can run the NFA using the just-in-time simulation (avoids exponential state-space blow-up).",
            "title": "Pattern searching"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#data-validation",
            "text": "Within XML we can enforce constraints on parts of the data.  For text fields on web froms, we can check if the input text is in the correct form.",
            "title": "Data validation"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#lexing",
            "text": "Even tough a higher level language is to complex to be regular, regular expressions can be used to identify the fundemental building blocks (tokens) of the language.   Lexical Analysis  Breaking up source code into a series of tagged tokens (lexemes)  Lexical class  The class of a token, for example  1000  would be an integer literal,  foobar  would be an identifier.",
            "title": "Lexing"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#how-lexers-work",
            "text": "Build NFA's for the lexical classes   (in order of priority)  Run the 'parrallel' automaton   until it expires  The last point in which we were in an accepting state is the largest match, chose the smallest   such that were in an accepting state of  . Chose class   as the lexical class for   which is the highest priorty.  Perform the specified action for the class",
            "title": "How lexers work"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#verification",
            "text": "Regulare langauge theory can help verify desirable properites:   Saftey, i.e.  bad things dont happen  Liveness, i.e.  good things do happen  Fierness, i.e.  things good for some processes dont cause to much badness to others",
            "title": "Verification"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#example",
            "text": "Suppose we have two processes   that have use of a shared resource, but must not be given access at the same time.   can comunicate using three shared flags\n-  req0  initially false, whether   wants access\n-  req1  initially false, whether   wants access\n-  turn  who is being allowed a turn  Code for   when it wants access  req0 = true\nturn = 1\nwhile(req1 && turn == 1) WAIT\n// P0 can now access resource\nreq0 = false  Code for   is the same with   swapped and  req0  and  req1 swapped.  This can be moddled by a finite state machine:  The language for the complete system can now be obtained: \nwhere   is the interleaving of regular langauges.  Now machine   with 200 states can be built.  Now we can verify\n- Mutual exclusion:   and   can never access simulaneously.\n- Progress",
            "title": "Example"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#the-pumping-lemma",
            "text": "",
            "title": "The Pumping Lemma"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#loops-in-dfas",
            "text": "A machine   with states   will always have a loop since we can process strings   where  , thus we visit some state twice. Thus any string   can be decomposed into:\n-  , the prefix of   that leads to the first visit of the repeated state  \n-  , the loop which goes from   to  \n-  , whatever is left of   after",
            "title": "Loops in DFA's"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#lemma",
            "text": "Suppose   is a regular language, then   has the following property  :  Their exists   such that, for all strings   with   and  , there exist strings   such that  ,  , and for every   we have",
            "title": "Lemma"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#contrapositive",
            "text": "To prove a language is not reqular, we take the contrapositive of the pumping lemma  :  For all  , there exist strings   with   and   such that, for every decomposition of   as   where  , their is some   which",
            "title": "Contrapositive"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#using-the-pumping-lemma",
            "text": "Your argument must work for all  .  Choose strings   (which might depend on  ) to satisfy   and  . Additionaly   should \"disallow pumping\" (number of loops depend on language).  Your argument must work for all decompositions of   as   with  .  Choose the number   such that  , here   might depend on all the previous data.",
            "title": "Using the pumping lemma"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#example-1",
            "text": "Show that   is not regular   Suppose   Let  ,  ,   Let    for some   Thus   , thus   satisfys  , thus it is not regular",
            "title": "Example 1"
        },
        {
            "location": "/Processing-Formal-and-Natural-Languages/#example-2",
            "text": "Show that   is not regular   Suppose   Let  ,  ,   so   Given   where  ,   (since   is non empry and the length of   is length  )  Let  , thus  ,   The length of the new string becomes   The next perfect string after   is  k^2 + 2k + 1 k^2 (k+1)^2 =   Thus   isnt a perfect square, thus   Thus   satisfys  , thus it is not regular",
            "title": "Example 2"
        }
    ]
}